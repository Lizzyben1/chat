<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Global Chat — Chat + DMs + Friends + Settings</title>
<style>
  :root{
    --bg-dark:#0b0f14; --card-dark:#121922; --muted:#8aa0b3; --border:#1e2a36;
    --accent:#4da3ff; --gold:#f5c542; --danger:#ff6b6b;
    --bg-light:#f6f8fb; --card-light:#ffffff; --text-light:#0b1620;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font:16px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:1080px;margin:24px auto;padding:0 16px}
  header{display:flex;gap:12px;align-items:center;margin:12px 0}
  h1{margin:0;font-size:22px}
  .pill{border:1px solid var(--border);border-radius:999px;padding:4px 10px;font-size:12px;background:var(--card)}
  .tabs{display:flex;gap:8px;margin-left:12px}
  .tab{padding:6px 10px;border-radius:999px;border:1px solid var(--border);cursor:pointer}
  .tab.active{background:rgba(255,255,255,0.03)}
  .row{display:flex;gap:16px;flex-wrap:wrap}
  .card{flex:1;min-width:280px;background:var(--card);border:1px solid var(--border);border-radius:12px;padding:12px}

  /* chat area */
  #messages{height:56vh;display:flex;flex-direction:column;gap:10px;scroll-behavior:smooth;padding-right:6px;overflow-y:auto;overflow-x:hidden}
  .msg{display:flex;position:relative}
  .bubble{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:8px 10px;max-width:80%;word-break:break-word;overflow-wrap:anywhere}
  .me .bubble{background:linear-gradient(180deg, rgba(11,32,54,1), rgba(10,30,50,1))}
  .name{font-weight:700;display:flex;align-items:center;gap:8px}
  .crown{color:var(--gold)}
  .text{white-space:pre-wrap}
  .ts{color:var(--muted);font-size:12px;margin-top:6px}
  .menu-btn{position:absolute;top:6px;right:6px;background:var(--card);border:1px solid var(--border);border-radius:8px;padding:2px 6px;cursor:pointer;font-size:12px}
  .menu{position:absolute;top:28px;right:6px;background:var(--card);border:1px solid var(--border);border-radius:10px;padding:6px;display:none;z-index:5;min-width:200px}
  .menu button{width:100%;text-align:left;padding:8px;border-radius:8px;border:1px solid var(--border);background:transparent;color:inherit;cursor:pointer;margin:4px 0}
  .menu button.danger{color:var(--danger)}

  .grouped .name{display:none}
  .grouped .bubble{margin-top:-6px}
  .group-start .bubble{margin-top:0}

  /* input */
  .row-input{display:flex;gap:10px;margin-top:10px;align-items:stretch}
  textarea{flex:1;min-height:46px;max-height:160px;resize:vertical;padding:10px;border-radius:8px;border:1px solid var(--border);background:transparent;color:inherit}
  button{padding:10px 14px;border-radius:8px;border:1px solid var(--border);background:transparent;color:inherit;cursor:pointer}
  button[disabled]{opacity:.5;cursor:not-allowed}
  .below{display:flex;justify-content:space-between;align-items:center;margin-top:8px}
  .tiny{font-size:12px;color:var(--muted)}
  .right{margin-left:auto;display:flex;gap:8px;align-items:center}

  /* side column */
  .side-list{display:flex;flex-direction:column;gap:8px}
  .item{padding:8px;border-radius:8px;border:1px solid var(--border);background:transparent;display:flex;justify-content:space-between;align-items:center}
  .badge{background:var(--accent);padding:4px 8px;border-radius:999px;color:#fff;font-size:12px}

  /* dm area */
  #dmList{max-height:28vh;overflow:auto;display:flex;flex-direction:column;gap:6px}
  #dmThread{max-height:44vh;overflow:auto;padding:8px;display:flex;flex-direction:column;gap:8px}

  /* friends */
  .friend-actions{display:flex;gap:6px}

  /* settings */
  .setting{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;border:1px solid var(--border);margin-top:8px}

  /* theme light/dark vars default -> dark */
  :root { --bg:var(--bg-dark); --card:var(--card-dark); --text:#e6eef6; }
  body.light { --bg:var(--bg-light); --card:var(--card-light); --text:var(--text-light); --border:#e0e6ee; --muted:#6b7280; }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Global Chat</h1>
    <div class="tabs" id="mainTabs">
      <div class="tab active" data-tab="chat">Chat</div>
      <div class="tab" data-tab="dms">Direct Messages <span id="dmBadge" style="margin-left:6px"></span></div>
      <div class="tab" data-tab="friends">Friends</div>
      <div class="tab" data-tab="settings">Settings</div>
    </div>
    <div class="right">
      <span class="pill">auth: <span id="auth-state">loading…</span></span>
      <span class="pill">rt: <span id="rt-state">idle</span></span>
      <span id="whoami" class="pill" style="display:none;margin-left:8px"></span>
      <button id="signoutBtn" style="display:none;margin-left:6px">Sign out</button>
    </div>
  </header>

  <div class="row">
    <!-- Main chat column -->
    <div id="chatCol" class="card" style="flex:2">
      <!-- Chat view -->
      <div id="view-chat">
        <div id="messages"></div>

        <form id="form" class="row-input">
          <textarea id="input" placeholder="Write a message…" maxlength="500"></textarea>
          <button id="sendBtn" type="submit" disabled>Send</button>
        </form>

        <div class="below">
          <div class="tiny" id="counter">0 / 500</div>
          <div class="tiny right">
            <div id="throttleMsg"></div>
          </div>
        </div>
        <div class="tiny" id="banNotice" style="margin-top:8px;color:var(--danger)"></div>
      </div>

      <!-- DM view -->
      <div id="view-dms" style="display:none">
        <div style="display:flex;gap:10px">
          <div style="flex:1">
            <div style="font-weight:700;margin-bottom:6px">Conversations</div>
            <div id="dmList"></div>
          </div>
          <div style="flex:2;display:flex;flex-direction:column">
            <div style="display:flex;justify-content:space-between;align-items:center">
              <div style="font-weight:700" id="dmHeader">Select conversation</div>
              <div><button id="newConvBtn" style="display:none">New DM</button></div>
            </div>
            <div id="dmThread" class="card" style="flex:1;margin-top:8px;min-height:220px"></div>

            <form id="dmForm" class="row-input" style="margin-top:8px;display:none">
              <textarea id="dmInput" placeholder="Write a private message…" maxlength="1000"></textarea>
              <button id="dmSend" type="submit">Send DM</button>
            </form>
          </div>
        </div>
      </div>

      <!-- Friends view -->
      <div id="view-friends" style="display:none">
        <div style="display:flex;gap:12px">
          <div style="flex:1">
            <div style="font-weight:700">Your friends</div>
            <div id="friendsList" style="margin-top:8px"></div>
          </div>
          <div style="flex:1">
            <div style="font-weight:700">Friend requests</div>
            <div id="friendRequests" style="margin-top:8px"></div>
          </div>
        </div>
      </div>

      <!-- Settings view -->
      <div id="view-settings" style="display:none">
        <div style="font-weight:700">Settings</div>
        <div class="setting">
          <div>Theme</div>
          <div>
            <button id="themeToggle">Toggle theme</button>
          </div>
        </div>
        <div class="setting">
          <div>Allow DMs from non-friends</div>
          <div><input type="checkbox" id="allowDMToggle"></div>
        </div>
        <div class="setting">
          <div>Censor swears/slurs (client only)</div>
          <div><input type="checkbox" id="censorToggle"></div>
        </div>
        <div class="setting">
          <div>Show DMs unread badge</div>
          <div><input type="checkbox" id="dmBadgeToggle" checked></div>
        </div>
      </div>
    </div>

    <!-- Side column (auth/mod/tools) -->
    <div id="sideCol" class="card" style="flex:1">
      <div id="authArea">
        <button id="googleBtn" style="width:100%;margin-bottom:10px">Continue with Google</button>
        <div style="display:flex;gap:8px">
          <div class="tab active" id="signinTab">Sign in</div>
          <div class="tab" id="signupTab">Sign up</div>
        </div>

        <div id="signinPane" style="margin-top:8px">
          <form id="signinForm">
            <input id="si-email" type="email" placeholder="Email" required style="width:100%;padding:8px;border-radius:6px;margin-bottom:6px;border:1px solid var(--border);background:transparent;color:inherit">
            <input id="si-pass" type="password" placeholder="Password" required style="width:100%;padding:8px;border-radius:6px;margin-bottom:6px;border:1px solid var(--border);background:transparent;color:inherit">
            <button style="width:100%">Sign in</button>
          </form>
        </div>

        <div id="signupPane" style="margin-top:8px;display:none">
          <form id="signupForm">
            <input id="su-username" placeholder="Username (a–z, 0–9, _)" minlength="3" maxlength="20" required style="width:100%;padding:8px;border-radius:6px;margin-bottom:6px;border:1px solid var(--border);background:transparent;color:inherit">
            <input id="su-email" type="email" placeholder="Email" required style="width:100%;padding:8px;border-radius:6px;margin-bottom:6px;border:1px solid var(--border);background:transparent;color:inherit">
            <input id="su-pass" type="password" placeholder="Password (min 6 chars)" minlength="6" required style="width:100%;padding:8px;border-radius:6px;margin-bottom:6px;border:1px solid var(--border);background:transparent;color:inherit">
            <button style="width:100%">Create account</button>
          </form>
        </div>

        <div id="usernameOnboard" style="display:none;margin-top:8px">
          <form id="unameForm">
            <input id="uname-input" placeholder="Pick a username" minlength="3" maxlength="20" style="width:100%;padding:8px;border-radius:6px;border:1px solid var(--border);background:transparent;color:inherit">
            <button style="width:100%;margin-top:6px">Save username</button>
          </form>
        </div>
        <div id="authMsg" style="margin-top:8px;color:var(--muted)"></div>
      </div>

      <div id="modPanel" style="display:none;margin-top:12px">
        <div style="font-weight:700">Moderation</div>
        <div style="margin-top:8px">
          <div style="font-weight:600">Muted/Banned</div>
          <div id="modBans" style="margin-top:6px"></div>
        </div>
        <div style="margin-top:12px">
          <div style="font-weight:600">Flagged</div>
          <div id="modFlags" style="margin-top:6px"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<script type="module">
/* ========== Firebase SDKs ========== */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
import {
  getAuth, onAuthStateChanged, signOut,
  createUserWithEmailAndPassword, signInWithEmailAndPassword, updateProfile,
  GoogleAuthProvider, signInWithPopup, signInWithRedirect, getRedirectResult, linkWithPopup
} from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";
import {
  getFirestore, doc, setDoc, getDoc, collection, addDoc, runTransaction,
  serverTimestamp, query, orderBy, limit, onSnapshot, deleteDoc, getDocs, where
} from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

/* ========== Config ========== */
const firebaseConfig = {
  apiKey: "AIzaSyD782fUtLrYCszRZhXIi9jBpZEDjDtZrcw",
  authDomain: "poopy-games-chat.firebaseapp.com",
  projectId: "poopy-games-chat",
  storageBucket: "poopy-games-chat.firebasestorage.app",
  messagingSenderId: "412556849195",
  appId: "1:412556849195:web:643791cd55e173f9fbba6e",
  measurementId: "G-ELSV57GKEP"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);

/* ========== DOM refs ========== */
const tabs = document.querySelectorAll('#mainTabs .tab');
const dmBadgeEl = document.getElementById('dmBadge');

const viewChat = document.getElementById('view-chat');
const viewDMs = document.getElementById('view-dms');
const viewFriends = document.getElementById('view-friends');
const viewSettings = document.getElementById('view-settings');

const messagesEl = document.getElementById('messages');
const form = document.getElementById('form');
const input = document.getElementById('input');
const sendBtn = document.getElementById('sendBtn');
const counterEl = document.getElementById('counter');
const throttleMsg = document.getElementById('throttleMsg');
const banNotice = document.getElementById('banNotice');

const sideCol = document.getElementById('sideCol');
const authArea = document.getElementById('authArea');
const authState = document.getElementById('auth-state');
const rtState = document.getElementById('rt-state');
const whoami = document.getElementById('whoami');
const signoutBtn = document.getElementById('signoutBtn');

const googleBtn = document.getElementById('googleBtn');
const signinTab = document.getElementById('signinTab');
const signupTab = document.getElementById('signupTab');
const signinPane = document.getElementById('signinPane');
const signupPane = document.getElementById('signupPane');
const authMsg = document.getElementById('authMsg');
const usernameOnboard = document.getElementById('usernameOnboard');

const dmListEl = document.getElementById('dmList');
const dmThreadEl = document.getElementById('dmThread');
const dmForm = document.getElementById('dmForm');
const dmInput = document.getElementById('dmInput');
const dmSend = document.getElementById('dmSend');
const dmHeader = document.getElementById('dmHeader');

const friendsList = document.getElementById('friendsList');
const friendRequests = document.getElementById('friendRequests');

const modPanel = document.getElementById('modPanel');
const modBans = document.getElementById('modBans');
const modFlags = document.getElementById('modFlags');

const allowDMToggle = document.getElementById('allowDMToggle');
const censorToggle = document.getElementById('censorToggle');
const themeToggle = document.getElementById('themeToggle');
const dmBadgeToggle = document.getElementById('dmBadgeToggle');

const unameForm = document.getElementById('unameForm');
const unameInput = document.getElementById('uname-input');

/* ========== constants & refs ========== */
const ROOM_ID = 'global';
const OWNER_EMAIL = 'fressolaben@gmail.com';
const MAX_LEN = 500;
const GROUP_WINDOW_MS = 5 * 60 * 1000;

const msgsRef = collection(db, 'rooms', ROOM_ID, 'messages');
const bansColl = collection(db, 'rooms', ROOM_ID, 'bans');
const modsColl = collection(db, 'rooms', ROOM_ID, 'mods');
const flagsColl = collection(db, 'rooms', ROOM_ID, 'flags');

const usersCol = collection(db, 'users');
const dmsRoot = collection(db, 'dms'); // collections created via doc(db,'dms',convId)

/* ========== local state ========== */
let currentTab = 'chat';
let modUIDs = new Set();
let lastUid = null, lastTsMs = 0;
let sendingDisabledByBan = false;
let sendTimes = [], cooldownUntil = 0, lastSentAt = 0;
let blocked = ( () => { try { return new Set(JSON.parse(localStorage.getItem('blocked_uids')||'[]')); } catch { return new Set(); } })();
let deviceId = ( () => { let id = localStorage.getItem('device_id'); if(!id){ id = crypto.randomUUID(); localStorage.setItem('device_id', id);} return id; })();

let mySettings = { allowDMs: true, censor: false, theme: 'dark', showDmBadge: true };
let currentUser = null;
let currentDMConv = null; // {id, otherUid}

/* ========== helper funcs ========== */
function setTheme(theme){ if(theme === 'light'){ document.body.classList.add('light'); } else { document.body.classList.remove('light'); } }
function updateCounter(){ const len = input.value.length; counterEl.textContent = `${len} / ${MAX_LEN}`; sendBtn.disabled = (len===0 || len>MAX_LEN || !auth.currentUser || isRateLimited() || sendingDisabledByBan); }
function isRateLimited(){ const now=Date.now(); while(sendTimes.length && now-sendTimes[0] > 2000) sendTimes.shift(); if(now < cooldownUntil){ const rem = Math.ceil((cooldownUntil-now)/1000); throttleMsg.textContent = `Slow mode: 1 msg/sec for ${rem}s`; if(now - lastSentAt < 1000) return true; return false; } throttleMsg.textContent=''; if(sendTimes.length>5){ cooldownUntil = now + 10000; throttleMsg.textContent='Slow mode: 1 msg/sec for 10s'; } return false; }
function noteSent(){ const n = Date.now(); sendTimes.push(n); lastSentAt = n; updateCounter(); }
function fmtTime(ts){ try{ return new Date(ts?.toMillis?.() ?? ts).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}); } catch { return ''; } }
function convIdFrom(u1,u2){ return [u1,u2].sort().join('_'); }

/* ========== AutoMod / Slur handling (client-side) ========== */
function normalizeText(s){
  return s.toLowerCase()
    .normalize('NFD').replace(/\p{Diacritic}/gu,'')
    .replace(/[@]/g,'a').replace(/0/g,'o').replace(/[1l!]/g,'i').replace(/3/g,'e').replace(/4/g,'a').replace(/5/g,'s').replace(/7/g,'t')
    .replace(/[^a-z0-9 ]+/g,' ')
    .replace(/(\w)\1{2,}/g,'$1$1')
    .replace(/\s+/g,' ').trim();
}
const SLURS = ['nigger','nigga','chink','spic','faggot','retard','tranny','kike','wetback'];
const SLUR_RE = new RegExp(`\\b(${SLURS.map(x=>x.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')).join('|')})\\b`,'i');
function containsSlur(s){ return SLUR_RE.test(normalizeText(s||'')); }
function censorText(s){
  const norm = normalizeText(s);
  return s.replace(new RegExp(`\\b(${SLURS.map(x=>x.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')).join('|')})\\b`,'ig'), (m)=>'*'.repeat(Math.max(1,m.length)));
}

/* ========== UI helpers ========== */
function switchTab(tab){
  currentTab = tab;
  tabs.forEach(t=>t.classList.toggle('active', t.dataset.tab === tab));
  viewChat.style.display = tab === 'chat' ? '' : 'none';
  viewDMs.style.display = tab === 'dms' ? '' : 'none';
  viewFriends.style.display = tab === 'friends' ? '' : 'none';
  viewSettings.style.display = tab === 'settings' ? '' : 'none';
  if(tab === 'dms') loadDMConversations();
  if(tab === 'friends') loadFriendsAndRequests();
}
document.querySelectorAll('#mainTabs .tab').forEach(t=>t.addEventListener('click', ()=> switchTab(t.dataset.tab)));

/* ========== DOM renderers ========== */
// render a public chat message with grouping and menu
function makeUserMenu(docId, m){
  const wrap = document.createElement('div'); wrap.className='menu';
  const me = currentUser && currentUser.uid === m.uid;
  const amMod = currentUser && (modUIDs.has(currentUser.uid) || currentUser.email === OWNER_EMAIL);

  function add(label, fn, danger=false){
    const b = document.createElement('button'); b.textContent = label; if(danger) b.classList.add('danger');
    b.onclick = async (e)=>{ e.stopPropagation(); wrap.style.display='none'; try{ await fn(); } catch(err){ alert('Action failed: '+(err.message||String(err))); console.error(err); } };
    wrap.appendChild(b);
  }

  if(me || amMod) add('Delete message', ()=> deleteDoc(doc(db,'rooms',ROOM_ID,'messages',docId)), true);
  add(blocked.has(m.uid) ? 'Unblock user (local)' : 'Block user (local)', ()=> { if(blocked.has(m.uid)) blocked.delete(m.uid); else blocked.add(m.uid); localStorage.setItem('blocked_uids', JSON.stringify(Array.from(blocked))); document.querySelectorAll(`[data-uid="${m.uid}"]`).forEach(el=>el.classList.toggle('collapsed', blocked.has(m.uid)));});
  add('Send friend request', async ()=> {
    if(!currentUser) { alert('Sign in first'); return; }
    if(blocked.has(m.uid)) { alert('You are blocked or have blocked this user'); return; }
    // cannot friend yourself
    if(currentUser.uid === m.uid) { alert("You can't friend yourself"); return; }
    await setDoc(doc(db,'users',m.uid,'friendRequests',currentUser.uid), { from: currentUser.uid, at: serverTimestamp(), name: currentUser.displayName || '' });
    alert('Friend request sent');
  });
  add('DM', async ()=> {
    if(!currentUser){ alert('Sign in first'); return; }
    if(blocked.has(m.uid) || blocked.has(currentUser.uid)){ alert('Cannot DM (blocked)'); return; }
    // check target's allowDMs
    const userSnap = await getDoc(doc(db,'users',m.uid));
    const allow = userSnap.exists() ? (userSnap.data().allowDMs !== false) : true;
    if(!allow){ alert('User has DMs turned off'); return; }
    openDMWith(m.uid, m.name || 'user');
  });

  // moderator actions
  if(amMod && m.uid){
    add('Mute…', async ()=> {
      const dur = prompt('Mute duration? (e.g., 10m, 1h, 1d)'); const ms = parseHumanDuration(dur);
      if(isNaN(ms)||ms<=0) { alert('Enter 10m, 1h, 1d'); return; }
      const reason = prompt('Reason (shown to user)') || '';
      await setDoc(doc(db,'rooms',ROOM_ID,'bans',m.uid), { muteUntil: new Date(Date.now()+ms), by: currentUser.email, reason, at: serverTimestamp() }, { merge:true });
    }, true);

    add('Ban…', async ()=> {
      const dur = prompt('Ban duration? (e.g., 1h, 1d, 7d)'); const ms = parseHumanDuration(dur);
      if(isNaN(ms)||ms<=0) { alert('Enter 1h, 1d, 7d'); return; }
      const reason = prompt('Reason (shown to user)') || '';
      await setDoc(doc(db,'rooms',ROOM_ID,'bans',m.uid), { banUntil: new Date(Date.now()+ms), perma:false, by: currentUser.email, reason, at: serverTimestamp() }, { merge:true });
    }, true);

    add('Perma-ban', async ()=> {
      if(!confirm('PERMANENT ban — continue?')) return;
      const reason = prompt('Reason (shown to user)') || '';
      await setDoc(doc(db,'rooms',ROOM_ID,'bans',m.uid), { perma:true, by: currentUser.email, reason, at: serverTimestamp() }, { merge:true });
    }, true);

    add('Unmute', ()=> setDoc(doc(db,'rooms',ROOM_ID,'bans',m.uid), { muteUntil: new Date(0) }, { merge:true }));
    add('Unban', ()=> setDoc(doc(db,'rooms',ROOM_ID,'bans',m.uid), { banUntil: new Date(0), perma:false }, { merge:true }));

    // grant/remove mod (owner protected on server rules too)
    if(currentUser && m.uid && m.uid !== currentUser.uid){
      if(modUIDs.has(m.uid)){
        add('Remove moderator', async ()=> { await deleteDoc(doc(db,'rooms',ROOM_ID,'mods', m.uid)); });
      } else {
        add('Grant moderator', async ()=> { await setDoc(doc(db,'rooms',ROOM_ID,'mods', m.uid), { isMod: true, by: currentUser.uid, at: serverTimestamp() }); });
      }
    }
  }

  return wrap;
}

function renderPublicMessage(docSnap, myUid){
  const m = docSnap.data();
  const row = document.createElement('div');
  row.className = 'msg';
  row.dataset.uid = m.uid || '';
  if(m.uid === myUid) row.classList.add('me');

  const bubble = document.createElement('div'); bubble.className = 'bubble';
  const name = document.createElement('div'); name.className='name';
  const label = document.createElement('span'); label.textContent = m.name || 'Anon';
  name.appendChild(label);
  if(m.uid && modUIDs.has(m.uid)){ const cr = document.createElement('span'); cr.className='crown'; cr.textContent=' 👑'; name.appendChild(cr); }

  let textToShow = m.text || '';
  if(mySettings.censor) textToShow = textToShow.replace(SLUR_RE, (s)=>'*'.repeat(Math.max(1,s.length)));
  const text = document.createElement('div'); text.className='text'; text.textContent = textToShow;
  const ts = document.createElement('div'); ts.className='ts'; ts.textContent = fmtTime(m.ts);

  const menuBtn = document.createElement('div'); menuBtn.className='menu-btn'; menuBtn.textContent='⋯';
  const menu = makeUserMenu(docSnap.id, m);
  menuBtn.onclick = (e)=>{ e.stopPropagation(); menu.style.display = (menu.style.display === 'block' ? 'none' : 'block'); };
  document.addEventListener('click', ()=> { menu.style.display = 'none'; });

  bubble.appendChild(name);
  bubble.appendChild(text);
  bubble.appendChild(ts);
  row.appendChild(bubble);
  row.appendChild(menuBtn);
  row.appendChild(menu);

  // collapsed if blocked
  if(blocked.has(m.uid)) row.classList.add('collapsed');

  // grouping
  const tsMs = m.ts?.toMillis?.() ?? Date.now();
  const grouped = (lastUid === m.uid) && (tsMs - lastTsMs <= GROUP_WINDOW_MS);
  row.classList.toggle('grouped', grouped);
  row.classList.toggle('group-start', !grouped);
  lastUid = m.uid; lastTsMs = tsMs;

  messagesEl.appendChild(row);
}

/* ========== DM functions ========== */
async function openDMWith(otherUid, otherName){
  const me = auth.currentUser;
  if(!me){ alert('Sign in first'); return; }
  if(blocked.has(otherUid) || blocked.has(me.uid)){ alert('Cannot DM (blocked)'); return; }
  const otherSnap = await getDoc(doc(db,'users',otherUid));
  const allowDMs = otherSnap.exists() ? (otherSnap.data().allowDMs !== false) : true;
  if(!allowDMs){ alert('User has DMs turned off'); return; }

  const id = convIdFrom(me.uid, otherUid);
  currentDMConv = { id, otherUid, otherName: otherName || (otherSnap.data()?.username || otherUid) };
  dmHeader.textContent = `DM — ${currentDMConv.otherName}`;
  dmForm.style.display = '';
  dmInput.value = '';
  dmThreadEl.innerHTML = '';

  // load last 200 messages
  const msgsQuery = query(collection(db,'dms', id, 'messages'), orderBy('ts','asc'), limit(500));
  onSnapshot(msgsQuery, (snap)=>{
    dmThreadEl.innerHTML = '';
    snap.forEach(d=>{
      const data = d.data();
      let txt = data.text || '';
      // censor locally if enabled
      if(mySettings.censor) txt = txt.replace(SLUR_RE, (s)=>'*'.repeat(Math.max(1,s.length)));
      const mdiv = document.createElement('div');
      mdiv.className = (data.senderId === me.uid) ? 'item' : 'item';
      mdiv.style.textAlign = data.senderId === me.uid ? 'right' : 'left';
      mdiv.textContent = `${data.senderName || (data.senderId)}: ${txt} (${fmtTime(data.ts)})`;
      dmThreadEl.appendChild(mdiv);
    });
    dmThreadEl.scrollTop = dmThreadEl.scrollHeight;
  });
  switchTab('dms');
}

/* ========== Friend system ========== */
async function loadFriendsAndRequests(){
  friendsList.innerHTML = ''; friendRequests.innerHTML = '';
  if(!currentUser) { friendsList.textContent = 'Sign in to see friends'; return; }
  // friends as subcollection under /users/{uid}/friends
  const friendsSnap = await getDocs(collection(db,'users', currentUser.uid, 'friends'));
  friendsSnap.forEach(d=>{
    const item = document.createElement('div'); item.className='item';
    item.textContent = d.id;
    const actions = document.createElement('div'); actions.className='friend-actions';
    const dmBtn = document.createElement('button'); dmBtn.textContent='DM'; dmBtn.onclick = ()=> openDMWith(d.id, d.id);
    const unfriend = document.createElement('button'); unfriend.textContent='Unfriend'; unfriend.onclick = async ()=> { await deleteDoc(doc(db,'users',currentUser.uid,'friends',d.id)); await deleteDoc(doc(db,'users',d.id,'friends',currentUser.uid)); loadFriendsAndRequests(); };
    actions.append(dmBtn, unfriend);
    item.appendChild(actions); friendsList.appendChild(item);
  });

  // friend requests (incoming)
  const reqSnap = await getDocs(collection(db,'users', currentUser.uid, 'friendRequests'));
  reqSnap.forEach(d=>{
    const data = d.data();
    const item = document.createElement('div'); item.className='item';
    item.textContent = `${data.name || d.id} (${d.id})`;
    const actions = document.createElement('div');
    const accept = document.createElement('button'); accept.textContent='Accept'; accept.onclick = async ()=>{
      await setDoc(doc(db,'users',currentUser.uid,'friends', d.id), { at: serverTimestamp() });
      await setDoc(doc(db,'users',d.id,'friends', currentUser.uid), { at: serverTimestamp() });
      await deleteDoc(doc(db,'users',currentUser.uid,'friendRequests', d.id));
      loadFriendsAndRequests();
    };
    const decline = document.createElement('button'); decline.textContent='Decline'; decline.onclick = async ()=> { await deleteDoc(doc(db,'users',currentUser.uid,'friendRequests', d.id)); loadFriendsAndRequests(); };
    actions.append(accept, decline);
    item.appendChild(actions); friendRequests.appendChild(item);
  });
}

/* ========== DM convs list ========== */
async function loadDMConversations(){
  dmListEl.innerHTML = '';
  if(!currentUser){ dmListEl.textContent = 'Sign in to use DMs'; return; }
  // Query dms where currentUser is in convId: naive approach — list dms by scanning small index
  // We'll store a small index on each user: /users/{uid}/dms/{convId:true} when a DM is created
  const dmsIndexSnap = await getDocs(collection(db,'users', currentUser.uid, 'dms'));
  const convs = [];
  dmsIndexSnap.forEach(d=> convs.push(d.id));
  if(convs.length === 0) { dmListEl.textContent = 'No conversations yet'; return; }
  for(const id of convs){
    const otherUid = id.split('_').find(x => x !== currentUser.uid);
    const otherSnap = await getDoc(doc(db,'users',otherUid));
    const display = otherSnap.exists() ? (otherSnap.data().username || otherUid) : otherUid;
    const item = document.createElement('div'); item.className='item';
    item.textContent = display;
    item.onclick = ()=> openDMWith(otherUid, display);
    dmListEl.appendChild(item);
  }
}

/* ========== Settings handling ========== */
async function loadMySettings(){
  if(!currentUser) return;
  const snap = await getDoc(doc(db,'users', currentUser.uid));
  if(snap.exists()){
    const d = snap.data();
    mySettings.allowDMs = d.allowDMs !== false;
    mySettings.censor = d.censor === true;
    mySettings.theme = d.theme || 'dark';
    mySettings.showDmBadge = d.showDmBadge !== false;
  } else {
    mySettings = { allowDMs: true, censor:false, theme:'dark', showDmBadge:true };
    await setDoc(doc(db,'users', currentUser.uid), { allowDMs: true, censor:false, theme:'dark', showDmBadge:true }, { merge:true });
  }
  // apply to UI
  allowDMToggle.checked = mySettings.allowDMs;
  censorToggle.checked = mySettings.censor;
  dmBadgeToggle.checked = mySettings.showDmBadge;
  setTheme(mySettings.theme);
}

/* toggle settings write */
allowDMToggle.addEventListener('change', async ()=>{
  if(!currentUser) return;
  mySettings.allowDMs = allowDMToggle.checked;
  await setDoc(doc(db,'users', currentUser.uid), { allowDMs: mySettings.allowDMs }, { merge:true });
});
censorToggle.addEventListener('change', async ()=>{
  if(!currentUser) return;
  mySettings.censor = censorToggle.checked;
  await setDoc(doc(db,'users', currentUser.uid), { censor: mySettings.censor }, { merge:true });
});
dmBadgeToggle.addEventListener('change', async ()=>{
  if(!currentUser) return;
  mySettings.showDmBadge = dmBadgeToggle.checked;
  await setDoc(doc(db,'users', currentUser.uid), { showDmBadge: mySettings.showDmBadge }, { merge:true });
});
themeToggle.addEventListener('click', async ()=>{
  mySettings.theme = (mySettings.theme === 'dark') ? 'light' : 'dark';
  setTheme(mySettings.theme);
  if(currentUser) await setDoc(doc(db,'users', currentUser.uid), { theme: mySettings.theme }, { merge:true });
});

/* ========== Signup / Signin / Google ========== */
signinTab.onclick = ()=> { signinPane.style.display='block'; signupPane.style.display='none'; };
signupTab.onclick = ()=> { signupPane.style.display='block'; signinPane.style.display='none'; };

document.getElementById('signupForm').addEventListener('submit', async (e)=>{
  e.preventDefault();
  const username = document.getElementById('su-username').value.trim().toLowerCase();
  const email = document.getElementById('su-email').value.trim();
  const pass = document.getElementById('su-pass').value;
  if(!/^[a-z0-9_]{3,20}$/.test(username)){ authMsg.textContent='Username: 3–20 chars a–z 0–9 _'; return; }
  try {
    const cred = await createUserWithEmailAndPassword(auth, email, pass);
    await claimUsernameTx(username, cred.user.uid);
    await updateProfile(cred.user, { displayName: username });
    // write default settings and deviceId
    await setDoc(doc(db,'users',cred.user.uid), { username, email, deviceId, allowDMs:true, censor:false, theme:'dark', showDmBadge:true, createdAt:serverTimestamp() }, { merge:true });
    authMsg.textContent = 'Account created and signed in';
  } catch(err){
    authMsg.textContent = err.message || String(err);
  }
});

document.getElementById('signinForm').addEventListener('submit', async (e)=>{
  e.preventDefault();
  const email = document.getElementById('si-email').value.trim();
  const pass = document.getElementById('si-pass').value;
  try { await signInWithEmailAndPassword(auth, email, pass); authMsg.textContent = 'Signed in'; }
  catch(err){ authMsg.textContent = err.message || String(err); }
});

const provider = new GoogleAuthProvider();
googleBtn.onclick = async ()=> {
  try { if(auth.currentUser) await linkWithPopup(auth.currentUser, provider); else await signInWithPopup(auth, provider); authMsg.textContent=''; }
  catch(err){ try{ authMsg.textContent=(err.code||'')+' — trying redirect…'; await signInWithRedirect(auth, provider); } catch(err2){ authMsg.textContent = err2.message || String(err2); } }
};
getRedirectResult(auth).catch(err => { if(err) authMsg.textContent = err.message || String(err); });

/* ========== Username registry claim ========== */
async function claimUsernameTx(username, uid){
  const uname = username.toLowerCase();
  const unameRef = doc(db,'usernames', uname);
  await runTransaction(db, async (tx)=>{
    const snap = await tx.get(unameRef);
    if(snap.exists()) throw new Error('Username already taken');
    tx.set(unameRef, { uid, at: serverTimestamp() });
  });
}

/* ========== Moderation helpers (simple setDoc wrapper) ========== */
async function setMute(uid, ms, reason){
  const until = ms>0 ? new Date(Date.now()+ms) : new Date(0);
  await setDoc(doc(db,'rooms',ROOM_ID,'bans', uid), { muteUntil: until, by: currentUser.email, at: serverTimestamp(), reason }, { merge:true });
}

/* ========== AutoMod flag & escalate (client-side) ========== */
async function flagAndEscalate(uid, name, email, text, reason, msgId=null){
  // create a flag for mods to review
  await addDoc(flagsColl, { uid, name, email: email||'', text, reason, msgId: msgId||'', deviceId, at: serverTimestamp() });
  // escalate strikes in /rooms/global/automod/{uid}
  const ref = doc(db,'rooms', ROOM_ID, 'automod', uid);
  const snap = await getDoc(ref);
  const now = Date.now();
  let strikes = 0, last = 0;
  if(snap.exists()){ strikes = snap.data().strikes || 0; last = snap.data().lastAt?.toMillis?.() || 0; }
  if(now - last > 24*3600*1000) strikes = 0;
  strikes += 1;
  const ladder = [60e3, 5*60e3, 10*60e3, 20*60e3, 3600e3, 6*3600e3, 86400e3*7, 86400e3*21, 86400e3*42];
  const muteMs = ladder[Math.min(strikes-1, ladder.length-1)];
  await setDoc(ref, { strikes, lastAt: serverTimestamp() }, { merge:true });
  await setMute(uid, muteMs, `AutoMod slur (strike ${strikes})`);
}

/* ========== parse human durations like 10m,1h,1d ========== */
function parseHumanDuration(s){ if(!s) return 0; const m = String(s).trim().match(/^(\d+)\s*([mhd])$/i); if(!m) return NaN; const v = +m[1], u = m[2].toLowerCase(); return u==='m'?v*60*1000:u==='h'?v*3600*1000:v*24*3600*1000; }

/* ========== Real-time: watch mods list (for crowns) but watch my mod doc separately to avoid reload loops ========== */
function watchModsList(){
  onSnapshot(modsColl, (snap)=>{
    const s = new Set(); snap.forEach(d=> s.add(d.id));
    modUIDs = s;
    paintHeader();
  });
}
let myModCached = null;
function watchMyModDoc(uid){
  if(!uid) return;
  const ref = doc(db,'rooms',ROOM_ID,'mods', uid);
  onSnapshot(ref, (snap)=>{
    const nowIs = snap.exists();
    if(myModCached === null){ myModCached = nowIs; return; }
    if(nowIs !== myModCached){ myModCached = nowIs; location.reload(); } // reload exactly once when it flips
  });
}
function paintHeader(){
  if(!currentUser) return;
  const crown = (modUIDs.has(currentUser.uid) || currentUser.email === OWNER_EMAIL) ? ' 👑' : '';
  whoami.style.display = 'inline-block';
  whoami.textContent = `@${currentUser.displayName || 'user'} · ${currentUser.email || ''}${crown}`;
}

/* ========== Realtime listeners and UI wiring ========== */
input.addEventListener('input', ()=> { updateCounter(); input.style.height='auto'; input.style.height = Math.min(input.scrollHeight,160)+'px'; });
input.addEventListener('keydown', (e)=> { if(e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); form.requestSubmit(); }});
dmInput.addEventListener('keydown', (e)=> { if(e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); dmForm.requestSubmit(); }});

form.addEventListener('submit', async (e)=>{
  e.preventDefault();
  if(!currentUser) { alert('Sign in first'); return; }
  const text = input.value.trim();
  if(!text || text.length > MAX_LEN) return;
  if(sendingDisabledByBan || isRateLimited()){ updateCounter(); return; }

  // client-side automod: if slur, block and flag & escalate; do not send
  if(containsSlur(text) || containsSlur(currentUser.displayName || '')){
    await flagAndEscalate(currentUser.uid, currentUser.displayName || '', currentUser.email || '', text, 'slur (blocked before send)', null);
    input.value = ''; updateCounter();
    return;
  }

  await addDoc(msgsRef, { uid: currentUser.uid, name: currentUser.displayName || 'Anon', text, ts: serverTimestamp() });
  noteSent(); input.value=''; updateCounter(); messagesEl.scrollTop = messagesEl.scrollHeight;
});

dmForm.addEventListener('submit', async (e)=>{
  e.preventDefault();
  if(!currentUser || !currentDMConv) { alert('No conversation'); return; }
  const text = dmInput.value.trim();
  if(!text) return;
  // blocked check
  if(blocked.has(currentDMConv.otherUid) || blocked.has(currentUser.uid)){ alert('Cannot DM (blocked)'); return; }
  // check target allowDMs
  const otherSnap = await getDoc(doc(db,'users', currentDMConv.otherUid));
  const allow = otherSnap.exists() ? (otherSnap.data().allowDMs !== false) : true;
  if(!allow){ alert('User has DMs turned off'); return; }
  // censor? this is client-only display; we still store original text in DB
  if(containsSlur(text) || containsSlur(currentUser.displayName || '')){
    // for DMs we follow your earlier instruction: when slur in DM and censor NOT enabled -> delete? you said earlier slurs auto-delete in public; for DMs we will block send and flag/escalate
    await flagAndEscalate(currentUser.uid, currentUser.displayName || '', currentUser.email || '', text, 'slur in DM (blocked)', null);
    dmInput.value = '';
    return;
  }
  const id = currentDMConv.id;
  const msgsCol = collection(db,'dms', id, 'messages');
  await addDoc(msgsCol, { senderId: currentUser.uid, senderName: currentUser.displayName || '', receiverId: currentDMConv.otherUid, text, ts: serverTimestamp() });
  // update indexes so both users can list the conv
  await setDoc(doc(db,'users', currentUser.uid, 'dms', id), { with: currentDMConv.otherUid, at: serverTimestamp() }, { merge:true });
  await setDoc(doc(db,'users', currentDMConv.otherUid, 'dms', id), { with: currentUser.uid, at: serverTimestamp() }, { merge:true });
  dmInput.value = ''; 
});

/* ========== Real-time public chat with auto slur-filtering for mods ========== */
onAuthStateChanged(auth, async (user) => {
  currentUser = user || null;
  if(!user){
    authState.textContent = 'signed out';
    whoami.style.display = 'none';
    signoutBtn.style.display = 'none';
    authArea.style.display = '';
    sideCol.style.display = '';
    modPanel.style.display = 'none';
    // show chat but maybe not allow send
    updateCounter();
    // render public chat for signed out user (listen as anonymous)
    startPublicListener(null);
    return;
  }

  authState.textContent = 'signed in';
  authArea.style.display = 'none';
  signoutBtn.style.display = '';
  // attach device id & ensure user doc (profile)
  await setDoc(doc(db,'users', user.uid), { email: user.email || '', username: user.displayName || '', deviceId, lastSeen: serverTimestamp() }, { merge:true });

  // load user-specific settings
  await loadMySettings();
  // watch mods and my mod doc
  watchModsList();
  watchMyModDoc(user.uid);
  paintHeader();

  // show/hide side column depending on mod status (note: mod list watcher updates modUIDs)
  const isMeMod = modUIDs.has(user.uid) || user.email === OWNER_EMAIL;
  if(isMeMod){
    sideCol.style.display = '';
    modPanel.style.display = '';
    chatCol.style.flex = '2';
    // attach mod-only listeners
    onSnapshot(bansColl, snap => { modBans.innerHTML=''; snap.forEach(d=>{ const b = d.data(); const el = document.createElement('div'); el.className='item'; el.textContent = `${d.id} — ${b.reason || ''}`; modBans.appendChild(el); }); });
    onSnapshot(query(flagsColl, orderBy('at','desc'), limit(200)), snap => { modFlags.innerHTML=''; snap.forEach(d=>{ const f = d.data(); const el = document.createElement('div'); el.className='item'; el.textContent = `${f.name || f.uid} — ${f.reason || ''} — ${f.text?.slice(0,80)}`; modFlags.appendChild(el); }); });
  } else {
    sideCol.style.display = 'none';
    modPanel.style.display = 'none';
    chatCol.style.flex = '1 1 100%';
  }

  // watch my ban doc for mute/ban
  onSnapshot(doc(db,'rooms',ROOM_ID,'bans', user.uid), snap => { showBanState(snap.data() || null); });

  // start public listener as authed user
  startPublicListener(user.uid);
});

/* start public listener (avoids mod-only reads for non-mods) */
function startPublicListener(myUid){
  const q = query(msgsRef, orderBy('ts','asc'), limit(500));
  onSnapshot(q, (snap) => {
    messagesEl.innerHTML = '';
    lastUid = null; lastTsMs = 0;
    snap.forEach(d => {
      const m = d.data();
      // if a slur is present and I'm a mod, delete and flag; if not mod, hide it
      if(containsSlur(m.text || '') || containsSlur(m.name || '')){
        if(currentUser && (modUIDs.has(currentUser.uid) || currentUser.email === OWNER_EMAIL)) {
          deleteDoc(doc(db,'rooms',ROOM_ID,'messages', d.id)).catch(()=>{});
        }
        // create flag best-effort (any authed user can create flag)
        if(currentUser) addDoc(flagsColl, { uid: m.uid, name: m.name || '', email: currentUser.email || '', text: m.text || '', reason: 'slur (autoscan)', msgId: d.id, at: serverTimestamp() }).catch(()=>{});
        return;
      }
      renderPublicMessage(d, myUid);
    });
    messagesEl.scrollTop = messagesEl.scrollHeight;
  }, (err) => { console.error('messages onSnapshot error', err); });
}

/* show ban/mute UI */
function showBanState(b){
  sendingDisabledByBan = false; banNotice.textContent = '';
  if(!b) return;
  const now = Date.now();
  const perma = !!b.perma;
  const muteUntil = b.muteUntil?.toMillis?.() ?? 0;
  const banUntil = b.banUntil?.toMillis?.() ?? 0;
  const reason = b.reason || '';
  if(perma || banUntil > now){
    sendingDisabledByBan = true;
    banNotice.textContent = (perma ? 'Permanently banned' : `Banned until ${new Date(banUntil).toLocaleString()}`) + (reason ? ` — ${reason}` : '');
  } else if(muteUntil > now){
    sendingDisabledByBan = true;
    banNotice.textContent = `Muted until ${new Date(muteUntil).toLocaleString()}` + (reason ? ` — ${reason}` : '');
  }
}

/* ========== Misc & helpers ========== */
function updateDmBadge(count){
  if(!mySettings.showDmBadge) { dmBadgeEl.textContent = ''; return; }
  if(!count) { dmBadgeEl.textContent = ''; return; }
  dmBadgeEl.innerHTML = `<span class="badge">${count}</span>`;
}

/* ========== Utility: show current user's dm conv count (unread tracking omitted for brevity) ========== */
async function refreshDmBadge(){
  if(!currentUser) { updateDmBadge(0); return; }
  const snaps = await getDocs(collection(db,'users', currentUser.uid, 'dms'));
  updateDmBadge(snaps.size);
}

/* ========== Username onboard submit ========== */
unameForm.addEventListener('submit', async (e)=>{
  e.preventDefault();
  const username = unameInput.value.trim().toLowerCase();
  if(!/^[a-z0-9_]{3,20}$/.test(username)){ authMsg.textContent='Use 3–20 chars: a–z,0–9,_'; return; }
  try {
    await claimUsernameTx(username, auth.currentUser.uid);
    await updateProfile(auth.currentUser, { displayName: username });
    await setDoc(doc(db,'users', auth.currentUser.uid), { username, lastUpdated: serverTimestamp() }, { merge:true });
    usernameOnboard.style.display = 'none';
    paintHeader();
  } catch(err){ authMsg.textContent = err.message || String(err); }
});

/* ========== Initial UI wiring ========== */
document.getElementById('tab-signin').addEventListener('click', ()=> { signinPane.style.display='block'; signupPane.style.display='none'; });
document.getElementById('tab-signup').addEventListener('click', ()=> { signupPane.style.display='block'; signinPane.style.display='none'; });
signoutBtn.addEventListener('click', ()=> signOut(auth));

setTheme('dark'); // default
updateCounter();
setInterval(updateCounter, 300);
setInterval(refreshDmBadge, 30000);
refreshDmBadge();

</script>
</body>
</html>
