<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Global Chat (Grouping + AutoMod + Flags)</title>
<style>
  :root{ --bg:#0b0f14; --card:#121922; --muted:#8aa0b3; --border:#1e2a36; --danger:#ff6b6b; --accent:#4da3ff; --gold:#f5c542; }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:#e6eef6;font:16px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:1080px;margin:24px auto;padding:0 16px}
  header{display:flex;gap:12px;align-items:center;margin:12px 0}
  h1{margin:0;font-size:22px}
  .pill{border:1px solid var(--border);border-radius:999px;padding:4px 10px;font-size:12px;background:#0f1620}
  .row{display:flex;gap:16px;flex-wrap:wrap}
  .card{flex:1;min-width:280px;background:#0f1620;border:1px solid var(--border);border-radius:16px;padding:12px}

  /* Chat */
  #messages{height:56vh;display:flex;flex-direction:column;gap:10px;scroll-behavior:smooth;padding-right:6px;overflow-y:auto;overflow-x:hidden}
  .msg{display:flex;position:relative}
  .bubble{background:#0e141c;border:1px solid var(--border);border-radius:14px;padding:10px 12px;max-width:80%;word-break:break-word;overflow-wrap:anywhere}
  .bubble *{max-width:100%}
  .me .bubble{background:#0b2036}
  .name{font-weight:600;display:flex;align-items:center;gap:6px}
  .crown{color:var(--gold);font-size:14px}
  .text{white-space:pre-wrap}
  .ts{color:#8aa0b3;font-size:12px;margin-top:4px}
  .menu-btn{position:absolute;top:6px;right:6px;background:#0f1a25;border:1px solid var(--border);border-radius:8px;padding:2px 6px;cursor:pointer;font-size:12px}
  .menu{position:absolute;top:28px;right:6px;background:#0e141c;border:1px solid var(--border);border-radius:10px;padding:6px;display:none;z-index:5;min-width:210px}
  .menu button{width:100%;text-align:left;padding:8px;border-radius:8px;border:1px solid var(--border);background:#0f1a25;color:#e6eef6;cursor:pointer;margin:4px 0}
  .menu button.danger{border-color:#3b1f24;background:#2a1216;color:#ffb3b3}

  /* Grouping */
  .grouped .name{display:none}               /* hide repeated username */
  .grouped .bubble{margin-top:-4px}          /* tighter stack */
  .group-start .bubble{margin-top:0}

  /* Input row */
  .chat-form{display:flex;gap:10px;margin-top:10px;align-items:stretch}
  .input-wrap{flex:1;display:flex}
  textarea{flex:1;min-height:46px;max-height:160px;resize:vertical;padding:12px;border-radius:12px;border:1px solid var(--border);background:#0e141c;color:#e6eef6;width:100%}
  button{padding:12px 16px;border-radius:12px;border:1px solid var(--border);background:#0f1a25;color:#e6eef6;cursor:pointer}
  button[disabled]{opacity:.6;cursor:not-allowed}
  .below-row{display:flex;justify-content:space-between;align-items:center;margin-top:6px}
  .tiny{font-size:12px;color:#8aa0b3}
  .right{display:flex;gap:8px;margin-left:auto}

  /* Auth & Mods */
  .auth form{display:grid;grid-template-columns:1fr;gap:8px}
  .tabs{display:flex;gap:8px;margin-bottom:8px}
  .tab{padding:6px 10px;border-radius:999px;border:1px solid var(--border);cursor:pointer}
  .tab.active{background:#162536}
  .collapsed{opacity:.75}
  .collapsed .text{display:none}
  .show-btn{margin-top:6px;font-size:12px;padding:4px 8px}

  .mod-panel{display:none;margin-top:12px}
  .mod-panel h3{margin:8px 0 6px 0;font-size:16px}
  .mod-search{display:flex;gap:8px}
  .mod-search input{flex:1;padding:8px;border-radius:8px;border:1px solid var(--border);background:#0e141c;color:#e6eef6}
  .section{margin-top:14px;padding-top:8px;border-top:1px dashed var(--border)}
  .ban-item,.flag-item{display:flex;gap:12px;align-items:center;border:1px solid var(--border);border-radius:10px;padding:10px;margin-top:8px;background:#0f1620}
  .ban-item .meta,.flag-item .meta{flex:1;min-width:0}
  .who{font-weight:600;overflow:hidden;text-overflow:ellipsis}
  .why{font-size:12px;color:#8aa0b3;overflow:hidden;text-overflow:ellipsis}
  .actions{display:flex;gap:8px;flex-wrap:wrap}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Global Chat</h1>
    <span class="pill">auth: <span id="auth-state">loadingâ€¦</span></span>
    <span class="pill">rt: <span id="rt-state">idle</span></span>
    <div class="right">
      <span id="whoami" class="pill" style="display:none"></span>
      <button id="signoutBtn" style="display:none">Sign out</button>
    </div>
  </header>

  <div class="row">
    <!-- Chat -->
    <div class="card" style="flex:2">
      <div id="messages"></div>
      <form id="form" class="chat-form">
        <div class="input-wrap"><textarea id="input" placeholder="Write a messageâ€¦" maxlength="500"></textarea></div>
        <button id="sendBtn" type="submit" disabled>Send</button>
      </form>
      <div class="below-row">
        <div class="tiny" id="counter">0 / 500</div>
        <div class="tiny" id="throttleMsg"></div>
      </div>
      <div class="tiny" id="banNotice" style="margin-top:6px;color:#ffb3b3"></div>
    </div>

    <!-- Auth / Mods column -->
    <div class="card auth" style="flex:1">
      <!-- sign-in area (auto-hidden when logged in) -->
      <div id="authArea">
        <button id="googleBtn" style="width:100%;margin-bottom:10px">Continue with Google</button>

        <div class="tabs">
          <div id="tab-signin" class="tab active">Sign in</div>
          <div id="tab-signup" class="tab">Sign up</div>
        </div>

        <div id="signin-pane">
          <form id="signinForm">
            <input id="si-email" type="email" placeholder="Email" required>
            <input id="si-pass" type="password" placeholder="Password" required>
            <button>Sign in</button>
          </form>
        </div>

        <div id="signup-pane" style="display:none">
          <form id="signupForm">
            <input id="su-username" placeholder="Username (aâ€“z, 0â€“9, _)" minlength="3" maxlength="20" required>
            <input id="su-email" type="email" placeholder="Email" required>
            <input id="su-pass" type="password" placeholder="Password (min 6 chars)" minlength="6" required>
            <button>Create account</button>
          </form>
        </div>

        <!-- Username onboarding after Google if needed -->
        <div id="username-onboard" style="display:none;margin-top:8px">
          <form id="unameForm">
            <input id="uname-input" placeholder="Pick a username (aâ€“z, 0â€“9, _)" minlength="3" maxlength="20" required>
            <button>Save username</button>
          </form>
          <div class="tiny">This sets your chat name and reserves it.</div>
        </div>

        <div id="auth-msg" style="color:#8aa0b3;margin-top:6px;min-height:1.2em"></div>
      </div>

      <!-- Mod panel -->
      <div id="modPanel" class="mod-panel">
        <div class="mod-search"><input id="modSearch" placeholder="Searchâ€¦"></div>

        <div class="section">
          <h3>Muted/Banned users</h3>
          <div id="modList"></div>
        </div>

        <div class="section">
          <h3>Flagged messages</h3>
          <div id="flagList"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
  import {
    getAuth, onAuthStateChanged, signOut,
    createUserWithEmailAndPassword, signInWithEmailAndPassword, updateProfile,
    GoogleAuthProvider, signInWithPopup, signInWithRedirect, getRedirectResult, linkWithPopup
  } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";
  import {
    getFirestore, doc, setDoc, getDoc, collection, addDoc, runTransaction,
    serverTimestamp, query, orderBy, limit, onSnapshot, deleteDoc, getDocs, where
  } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

  // ---------- Firebase config ----------
  const firebaseConfig = {
    apiKey: "AIzaSyD782fUtLrYCszRZhXIi9jBpZEDjDtZrcw",
    authDomain: "poopy-games-chat.firebaseapp.com",
    projectId: "poopy-games-chat",
    storageBucket: "poopy-games-chat.firebasestorage.app",
    messagingSenderId: "412556849195",
    appId: "1:412556849195:web:643791cd55e173f9fbba6e",
    measurementId: "G-ELSV57GKEP"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db   = getFirestore(app);

  // ---------- DOM ----------
  const messagesEl = document.getElementById('messages');
  const form = document.getElementById('form');
  const input = document.getElementById('input');
  const sendBtn = document.getElementById('sendBtn');
  const counter = document.getElementById('counter');
  const throttleMsg = document.getElementById('throttleMsg');
  const banNotice = document.getElementById('banNotice');
  const authState = document.getElementById('auth-state');
  const rtState   = document.getElementById('rt-state');
  const whoami    = document.getElementById('whoami');
  const signoutBtn= document.getElementById('signoutBtn');
  const authMsg   = document.getElementById('auth-msg');
  const googleBtn = document.getElementById('googleBtn');
  const unamePane = document.getElementById('username-onboard');
  const unameForm = document.getElementById('unameForm');
  const unameInput= document.getElementById('uname-input');
  const authArea  = document.getElementById('authArea');
  const modPanel  = document.getElementById('modPanel');
  const modSearch = document.getElementById('modSearch');
  const modList   = document.getElementById('modList');
  const flagList  = document.getElementById('flagList');
  const tabSignin = document.getElementById('tab-signin');
  const tabSignup = document.getElementById('tab-signup');
  const signinPane= document.getElementById('signin-pane');
  const signupPane= document.getElementById('signup-pane');

  tabSignin.onclick = () => { tabSignin.classList.add('active'); tabSignup.classList.remove('active'); signinPane.style.display='block'; signupPane.style.display='none'; if (authMsg) authMsg.textContent=''; };
  tabSignup.onclick = () => { tabSignup.classList.add('active'); tabSignin.classList.remove('active'); signupPane.style.display='block'; signinPane.style.display='none'; if (authMsg) authMsg.textContent=''; };

  // ---------- Room / collections ----------
  const ROOM_ID = 'global';
  const OWNER_EMAIL = 'fressolaben@gmail.com';
  const MAX_LEN = 500;
  const GROUP_WINDOW_MS = 5 * 60 * 1000;

  const msgsRef   = collection(db, 'rooms', ROOM_ID, 'messages');
  const bansColl  = collection(db, 'rooms', ROOM_ID, 'bans');
  const modsColl  = collection(db, 'rooms', ROOM_ID, 'mods');
  const flagsColl = collection(db, 'rooms', ROOM_ID, 'flags');
  const devicesColl = collection(db, 'rooms', ROOM_ID, 'devices');
  const autoModColl = collection(db, 'rooms', ROOM_ID, 'automod');

  const banDoc = (uid)=> doc(db, 'rooms', ROOM_ID, 'bans', uid);
  const modDoc = (uid)=> doc(db, 'rooms', ROOM_ID, 'mods', uid);
  const deviceDoc = (deviceId)=> doc(db, 'rooms', ROOM_ID, 'devices', deviceId);
  const autoDoc = (uid)=> doc(db, 'rooms', ROOM_ID, 'automod', uid);

  async function ensureRoom(){
    const roomRef = doc(db, 'rooms', ROOM_ID);
    const snap = await getDoc(roomRef);
    if (!snap.exists()) await setDoc(roomRef, { name: 'global chat', createdAt: serverTimestamp() }, { merge: true });
  }

  // ---------- Device ID (carry bans across new accounts) ----------
  function getDeviceId(){
    let id = localStorage.getItem('device_id');
    if (!id) { id = crypto.randomUUID(); localStorage.setItem('device_id', id); }
    return id;
  }
  const deviceId = getDeviceId();

  // ---------- Local blocks ----------
  const storageKey = 'blocked_uids';
  const getBlocked = ()=>{try{return new Set(JSON.parse(localStorage.getItem(storageKey)||'[]'))}catch{return new Set()}};
  const setBlocked = (s)=>localStorage.setItem(storageKey, JSON.stringify(Array.from(s)));
  let blocked = getBlocked();

  // ---------- Input / counter ----------
  function updateCounter(){
    const len = input.value.length;
    counter.textContent = `${len} / ${MAX_LEN}`;
    sendBtn.disabled = (len===0 || len>MAX_LEN || !auth.currentUser || isRateLimited() || sendingDisabledByBan);
  }
  input.addEventListener('input', () => { updateCounter(); input.style.height='auto'; input.style.height = Math.min(input.scrollHeight,160)+'px'; });
  input.addEventListener('keydown', (e)=>{ if (e.key==='Enter' && !e.shiftKey){ e.preventDefault(); form.requestSubmit(); }});
  updateCounter();

  // ---------- Time helpers ----------
  const mins = m=>m*60*1000, hours=h=>h*3600*1000, days=d=>d*24*3600*1000;
  const fmtTime = ts=>{try{return new Date(ts?.toMillis?.()??ts).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}catch{return''}};
  const fmtDateTime = ms=> new Date(ms).toLocaleString();
  function parseDuration(s){ if(!s) return 0; const m=String(s).trim().match(/^(\d+)\s*([mhd])$/i); if(!m) return NaN; const v=+m[1], u=m[2].toLowerCase(); return u==='m'?mins(v):u==='h'?hours(v):u==='d'?days(v):NaN; }

  // ---------- Mods set / crowns ----------
  let modUIDs = new Set();
  function watchModsFor(uid,email){
    onSnapshot(modsColl, (snap)=>{
      const before = modUIDs;
      const s=new Set(); snap.forEach(d=>s.add(d.id)); modUIDs=s;
      paintHeaderCrown();
      // If my mod status changed, reload my page to refresh UI/permissions
      const was = before.has(uid) || email===OWNER_EMAIL;
      const now = s.has(uid)     || email===OWNER_EMAIL;
      if (was !== now) location.reload();
    });
    // Also watch my specific mod doc directly (covers add/remove edges)
    onSnapshot(modDoc(uid), ()=>{}); // listener exists; global watcher handles reload
  }
  const isMod = (uid,email)=> modUIDs.has(uid) || email===OWNER_EMAIL;
  function paintHeaderCrown(){
    if(!auth.currentUser) return;
    const crown = isMod(auth.currentUser.uid, auth.currentUser.email) ? ' <span class="crown">ðŸ‘‘</span>' : '';
    whoami.innerHTML = `@${auth.currentUser.displayName || 'user'} Â· ${auth.currentUser.email || ''}${crown}`;
  }

  // ---------- Grouping state ----------
  let lastUid = null;
  let lastTsMs = 0;

  // ---------- Render messages (with grouping) ----------
  function makeMenu(msgId, m){
    const wrap=document.createElement('div'); wrap.className='menu';
    const me = auth.currentUser?.uid===m.uid;
    const amMod = isMod(auth.currentUser?.uid, auth.currentUser?.email);

    const add=(label,fn,danger=false)=>{const b=document.createElement('button'); b.textContent=label; if(danger)b.classList.add('danger'); b.onclick=async(e)=>{e.stopPropagation();wrap.style.display='none';await fn();}; wrap.appendChild(b);};

    if(me||amMod) add('Delete message', ()=>deleteDoc(doc(db,'rooms',ROOM_ID,'messages',msgId)), true);

    const isBlk = blocked.has(m.uid);
    add(isBlk?'Unblock user (local)':'Block user (local)', ()=>{ if(blocked.has(m.uid)) blocked.delete(m.uid); else blocked.add(m.uid); setBlocked(blocked); document.querySelectorAll(`[data-uid="${m.uid}"]`).forEach(el=>el.classList.toggle('collapsed',blocked.has(m.uid))); });

    if(amMod && m.uid){
      add('Muteâ€¦', async ()=>{ const dur=prompt('Mute duration? (e.g., 10m, 1h, 1d)'); const ms=parseDuration(dur); if(isNaN(ms)||ms<=0){alert('Enter 10m, 1h, 1d');return;} const reason=prompt('Reason (shown to user)')||''; await setMute(m.uid,ms,reason,true); }, true);
      add('Banâ€¦',  async ()=>{ const dur=prompt('Ban duration? (e.g., 1h, 1d, 7d)');  const ms=parseDuration(dur); if(isNaN(ms)||ms<=0){alert('Enter 1h, 1d, 7d');return;} const reason=prompt('Reason (shown to user)')||''; await setBan(m.uid,ms,reason,true); }, true);
      add('Perma-ban', async ()=>{ const reason=prompt('Reason (shown to user)')||''; if(!confirm('PERMANENT ban â€” continue?'))return; await setPerma(m.uid,reason,true); }, true);
      add('Unmute', ()=>setMute(m.uid,0,'',true));
      add('Unban',  ()=>setBan(m.uid,0,'',true));
      // Grant/remove mod (owner cannot be removed)
      if (m.email === OWNER_EMAIL) {
        // show but disabled
        add('Owner (cannot be changed)', ()=>{}, false);
      } else if(modUIDs.has(m.uid)) {
        add('Remove moderator', ()=>deleteDoc(modDoc(m.uid)));
      } else {
        add('Grant moderator', ()=>setDoc(modDoc(m.uid),{isMod:true,by:auth.currentUser.email,at:serverTimestamp()}));
      }
    }
    return wrap;
  }

  function renderMessage(docSnap, meUid){
    const d = docSnap.data();
    const tsMs = d.ts?.toMillis?.() ?? Date.now();

    const row=document.createElement('div'); row.className='msg'; row.dataset.uid=d.uid||'';
    const b=document.createElement('div'); b.className='bubble';

    const name=document.createElement('div'); name.className='name';
    const label=document.createElement('span'); label.textContent=d.name||'Anon'; name.appendChild(label);
    if(d.uid && modUIDs.has(d.uid)){const cr=document.createElement('span'); cr.className='crown'; cr.textContent='ðŸ‘‘'; name.appendChild(cr);}
    const text=document.createElement('div'); text.className='text'; text.textContent=d.text||'';
    const ts=document.createElement('div'); ts.className='ts'; ts.textContent=fmtTime(d.ts);

    // Grouping: hide name if same user within 5 min and previous was not too far
    const isGrouped = (lastUid === d.uid) && (tsMs - lastTsMs <= GROUP_WINDOW_MS);
    row.classList.toggle('grouped', isGrouped);
    row.classList.toggle('group-start', !isGrouped);

    const menuBtn=document.createElement('div'); menuBtn.className='menu-btn'; menuBtn.textContent='â‹¯';
    const menu=makeMenu(docSnap.id, d);
    menuBtn.onclick=(e)=>{e.stopPropagation(); menu.style.display=(menu.style.display==='block'?'none':'block');};
    document.addEventListener('click',()=>menu.style.display='none');

    b.append(name,text,ts); row.append(b,menuBtn,menu);
    if(blocked.has(d.uid)) row.classList.add('collapsed');
    if(blocked.has(d.uid)){const show=document.createElement('button'); show.className='show-btn'; show.textContent='Show message'; show.onclick=(e)=>{e.stopPropagation(); row.classList.remove('collapsed'); show.remove();}; b.appendChild(show);}

    // Update â€œlastâ€ trackers
    lastUid = d.uid; lastTsMs = tsMs;

    messagesEl.appendChild(row);
  }

  function scrollToBottom(){ messagesEl.scrollTop = messagesEl.scrollHeight; }

  // ---------- Username registry ----------
  async function claimUsernameTx(username, uid){
    const uname=username.toLowerCase(); const unameRef=doc(db,'usernames',uname);
    await runTransaction(db,async(tx)=>{ const s=await tx.get(unameRef); if(s.exists()) throw new Error('Username is taken'); tx.set(unameRef,{uid,at:serverTimestamp()}); });
  }

  // ---------- Google sign-in ----------
  const provider = new GoogleAuthProvider();
  googleBtn.onclick = async ()=>{
    try{ if(auth.currentUser) await linkWithPopup(auth.currentUser,provider); else await signInWithPopup(auth,provider); if(authMsg) authMsg.textContent=''; updateCounter(); }
    catch(err){ try{ if(authMsg) authMsg.textContent=(err.code||'')+' â€” trying redirectâ€¦'; await signInWithRedirect(auth,provider); } catch(err2){ if(authMsg) authMsg.textContent=err2.message||String(err2);} }
  };
  getRedirectResult(auth).catch(err=>{ if(err && authMsg) authMsg.textContent = err.message || String(err); });

  // ---------- Email/Password ----------
  document.getElementById('signupForm').addEventListener('submit', async (e)=>{
    e.preventDefault();
    const username=(document.getElementById('su-username').value||'').trim();
    const email=document.getElementById('su-email').value.trim();
    const pass=document.getElementById('su-pass').value;
    if(!/^[a-z0-9_]{3,20}$/i.test(username)){authMsg.textContent='Use 3â€“20 chars: aâ€“z, 0â€“9, _';return;}
    try{ const cred=await createUserWithEmailAndPassword(auth,email,pass); await claimUsernameTx(username,cred.user.uid); await updateProfile(cred.user,{displayName:username}); await setDoc(doc(db,'users',cred.user.uid),{username,email,deviceId,createdAt:serverTimestamp()},{merge:true}); authMsg.textContent='Account created. You are signed in.'; updateCounter(); }
    catch(err){ authMsg.textContent = err.message || String(err); }
  });
  document.getElementById('signinForm').addEventListener('submit', async (e)=>{
    e.preventDefault();
    const email=document.getElementById('si-email').value.trim();
    const pass =document.getElementById('si-pass').value;
    try{ await signInWithEmailAndPassword(auth,email,pass); authMsg.textContent='Signed in.'; updateCounter(); }
    catch(err){ authMsg.textContent = err.message || String(err); }
  });

  // ---------- Ban/mute UI state ----------
  let sendingDisabledByBan=false;
  function showBanState(b){
    sendingDisabledByBan=false; banNotice.textContent='';
    const now=Date.now(); if(!b) return;
    const perma=!!b.perma, muteUntil=b.muteUntil?.toMillis?.()??0, banUntil=b.banUntil?.toMillis?.()??0, reason=b.reason||'';
    if(perma || banUntil>now){ sendingDisabledByBan=true; banNotice.textContent=(perma?'Permanently banned':`Banned until ${fmtDateTime(banUntil)}`)+(reason?` â€” Reason: ${reason}`:''); }
    else if(muteUntil>now){ sendingDisabledByBan=true; banNotice.textContent=`Muted until ${fmtDateTime(muteUntil)}`+(reason?` â€” Reason: ${reason}`:''); }
  }

  // ---------- Anti-spam ----------
  const sendTimes=[]; let cooldownUntil=0; let lastSentAt=0;
  function isRateLimited(){
    const now=Date.now(); while(sendTimes.length && now-sendTimes[0]>2000) sendTimes.shift();
    if(now<cooldownUntil){ const rem=Math.ceil((cooldownUntil-now)/1000); throttleMsg.textContent=`Slow mode: 1 msg/sec for ${rem}s`; if(now-lastSentAt<1000) return true; return false; }
    throttleMsg.textContent=''; if(sendTimes.length>5){ cooldownUntil=now+10000; throttleMsg.textContent='Slow mode: 1 msg/sec for 10s'; } return false;
  }
  const noteSent=()=>{ const n=Date.now(); sendTimes.push(n); lastSentAt=n; updateCounter(); };

  // ---------- Mod writes + device carry ----------
  async function setMute(uid,ms,reason,alsoDevice){
    const until=ms>0?new Date(Date.now()+ms):new Date(0);
    await setDoc(banDoc(uid),{muteUntil:until,by:auth.currentUser.email,at:serverTimestamp(),reason:reason||''},{merge:true});
    if (alsoDevice) {
      const u = await getDoc(doc(db,'users',uid));
      const did = u.exists()? (u.data().deviceId||null) : null;
      if (did) await setDoc(deviceDoc(did), { muteUntil: until, by: auth.currentUser.email, at: serverTimestamp(), reason: reason||'' }, { merge:true });
    }
  }
  async function setBan(uid,ms,reason,alsoDevice){
    const until=ms>0?new Date(Date.now()+ms):new Date(0);
    await setDoc(banDoc(uid),{banUntil:until,perma:false,by:auth.currentUser.email,at:serverTimestamp(),reason:reason||''},{merge:true});
    if (alsoDevice) {
      const u = await getDoc(doc(db,'users',uid));
      const did = u.exists()? (u.data().deviceId||null) : null;
      if (did) await setDoc(deviceDoc(did), { banUntil: until, by: auth.currentUser.email, at: serverTimestamp(), reason: reason||'' }, { merge:true });
    }
  }
  async function setPerma(uid,reason,alsoDevice){
    await setDoc(banDoc(uid),{perma:true,banUntil:new Date(86400000),by:auth.currentUser.email,at:serverTimestamp(),reason:reason||''},{merge:true});
    if (alsoDevice) {
      const u = await getDoc(doc(db,'users',uid));
      const did = u.exists()? (u.data().deviceId||null) : null;
      if (did) await setDoc(deviceDoc(did), { perma: true, by: auth.currentUser.email, at: serverTimestamp(), reason: reason||'' }, { merge:true });
    }
  }

  // ---------- AutoMod (client-side) ----------
  // 1) normalize text (lowercase, remove accents, common leet, collapse repeats, keep letters/numbers/space)
  function normalize(s){
    return s
      .toLowerCase()
      .normalize('NFD').replace(/\p{Diacritic}/gu,'')
      .replace(/[@]/g,'a').replace(/[0]/g,'o').replace(/[1l!]/g,'i').replace(/[3]/g,'e').replace(/[4]/g,'a').replace(/[5$]/g,'s').replace(/[7]/g,'t')
      .replace(/[^a-z0-9 ]+/g,' ')
      .replace(/(\w)\1{2,}/g,'$1$1') // shrink loooong
      .replace(/\s+/g,' ')
      .trim();
  }
  // 2) slur list (add to this as needed; normalized compare)
  const SLURS = [
    // examples only; extend your list:
    'nigger','nigga','chink','spic','faggot','retard','tranny','kike','wetback'
  ];
  const SLUR_RE = new RegExp(`\\b(${SLURS.map(x=>x.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')).join('|')})\\b`,'i');

  async function flagAndEscalate(uid, name, email, text, reason, msgId=null){
    // write flag
    await addDoc(flagsColl, { uid, name, email: email||'', text, reason, msgId: msgId||'', deviceId, at: serverTimestamp() });

    // escalate strikes (reset if >24h)
    const ref = autoDoc(uid);
    const snap = await getDoc(ref);
    const now = Date.now();
    let strikes = 0, last = 0;
    if (snap.exists()) { strikes = snap.data().strikes||0; last = snap.data().lastAt?.toMillis?.() ?? 0; }
    if (now - last > 24*3600*1000) strikes = 0; // reset after 24h
    strikes += 1;

    const ladder = [mins(1), mins(5), mins(10), mins(20), hours(1), hours(6), days(7), days(21), days(42)];
    const muteMs = ladder[Math.min(strikes-1, ladder.length-1)];
    await setDoc(ref, { strikes, lastAt: serverTimestamp() }, { merge:true });
    await setMute(uid, muteMs, `AutoMod slur (strike ${strikes})`, true);
  }

  function containsSlur(s){
    const n = normalize(s);
    return SLUR_RE.test(n);
  }

  // ---------- Sign out ----------
  signoutBtn.onclick = async ()=>{ await signOut(auth); updateCounter(); };

  // ---------- Mod list render ----------
  function renderModList(allDocs){
    const q=(modSearch.value||'').toLowerCase(); modList.innerHTML='';
    allDocs.forEach(d=>{
      const b=d.data(), uid=d.id, now=Date.now();
      const status=[]; if(b.perma) status.push('PERMA BAN'); if((b.banUntil?.toMillis?.()??0)>now) status.push('BANNED'); if((b.muteUntil?.toMillis?.()??0)>now) status.push('MUTED');
      if(status.length===0) return;
      const reason=b.reason||'';
      if(q && ![uid,reason,status.join(', ')].join(' ').toLowerCase().includes(q)) return;

      const item=document.createElement('div'); item.className='ban-item';
      const meta=document.createElement('div'); meta.className='meta';
      const who=document.createElement('div'); who.className='who'; who.textContent=uid;
      const why=document.createElement('div'); why.className='why'; why.textContent=`${status.join(', ')}${reason?' â€” '+reason:''}`;
      meta.append(who,why);

      const actions=document.createElement('div'); actions.className='actions';
      const unmute=document.createElement('button'); unmute.textContent='Unmute'; unmute.onclick=()=>setMute(uid,0,'',true);
      const unban =document.createElement('button');  unban.textContent='Unban';  unban.onclick=()=>setBan(uid,0,'',true);
      actions.append(unmute,unban);

      item.append(meta,actions); modList.appendChild(item);
    });
  }

  // ---------- Flag queue render ----------
  function renderFlagList(docs){
    flagList.innerHTML='';
    const q=(modSearch.value||'').toLowerCase();
    docs.forEach(d=>{
      const f=d.data();
      const hay=[d.id, f.uid||'', f.name||'', f.email||'', f.text||'', f.reason||''].join(' ').toLowerCase();
      if(q && !hay.includes(q)) return;

      const item=document.createElement('div'); item.className='flag-item';
      const meta=document.createElement('div'); meta.className='meta';
      const who=document.createElement('div'); who.className='who'; who.textContent = `${f.name||'user'} (${f.uid||'?'})`;
      const why=document.createElement('div'); why.className='why'; why.textContent = `${f.reason||''} â€” ${f.text||''}`;
      meta.append(who,why);

      const actions=document.createElement('div'); actions.className='actions';
      const delMsg=document.createElement('button'); delMsg.textContent='Delete message'; delMsg.onclick=()=>{ if(!f.msgId) return; deleteDoc(doc(db,'rooms',ROOM_ID,'messages',f.msgId)); };
      const mute5 =document.createElement('button'); mute5.textContent='Mute 5m'; mute5.onclick =()=> setMute(f.uid, mins(5), 'Flag action', true);
      const ban1d=document.createElement('button'); ban1d.textContent='Ban 1d'; ban1d.onclick =()=> setBan(f.uid, days(1), 'Flag action', true);
      const clear =document.createElement('button'); clear.textContent='Clear';  clear.onclick=()=> deleteDoc(doc(db,'rooms',ROOM_ID,'flags',d.id));
      if (f.msgId) actions.append(delMsg);
      actions.append(mute5, ban1d, clear);

      item.append(meta,actions); flagList.appendChild(item);
    });
  }

  // ---------- Auth + realtime ----------
  onAuthStateChanged(auth, async (user)=>{
    if(!user){
      authState.textContent='signed out';
      whoami.style.display='none'; signoutBtn.style.display='none';
      authArea.style.display='block'; modPanel.style.display='none'; unamePane.style.display='none';
      updateCounter(); return;
    }
    authState.textContent='signed in';
    whoami.style.display='inline-block'; signoutBtn.style.display='inline-block';
    authArea.style.display='none';

    await ensureRoom();

    // attach device to user profile (for device bans)
    await setDoc(doc(db,'users',user.uid), { email:user.email||'', username:user.displayName||'', deviceId, lastSeen:serverTimestamp() }, { merge:true });

    // If device banned/muted, mirror to user ban doc
    const devSnap = await getDoc(deviceDoc(deviceId));
    if (devSnap.exists()) {
      const d=devSnap.data();
      await setDoc(banDoc(user.uid), d, { merge:true });
    }

    // start mods stream & crowns; auto-reload if my mod status flips
    watchModsFor(user.uid, user.email);
    paintHeaderCrown();

    // Username onboarding if not reserved
    let showOnboard=true;
    if(user.displayName){
      const claimed=await getDoc(doc(db,'usernames',user.displayName.toLowerCase()));
      showOnboard=!(claimed.exists() && claimed.data().uid===user.uid);
    }
    unamePane.style.display=showOnboard?'block':'none';

    // my ban/mute banner
    onSnapshot(banDoc(user.uid),(snap)=>showBanState(snap.data()||null));

    // If mod, show mod panel (bans + flags)
    const iAmMod = isMod(user.uid, user.email);
    modPanel.style.display = iAmMod ? 'block' : 'none';
    if(iAmMod){
      onSnapshot(bansColl,(snap)=>{ const docs=[]; snap.forEach(d=>docs.push(d)); renderModList(docs); });
      onSnapshot(query(flagsColl, orderBy('at','desc'), limit(200)), (snap)=>{ const docs=[]; snap.forEach(d=>docs.push(d)); renderFlagList(docs); });
      modSearch.addEventListener('input', async ()=>{
        const [bSnap, fSnap] = await Promise.all([getDocs(bansColl), getDocs(flagsColl)]);
        const bDocs=[], fDocs=[]; bSnap.forEach(d=>bDocs.push(d)); fSnap.forEach(d=>fDocs.push(d));
        renderModList(bDocs); renderFlagList(fDocs);
      });
    }

    // realtime messages with grouping and mod-side auto-delete if slur slipped through
    const qy=query(msgsRef, orderBy('ts','asc'), limit(500));
    rtState.textContent='listening';
    onSnapshot(qy,(snap)=>{
      messagesEl.innerHTML=''; lastUid=null; lastTsMs=0;
      snap.forEach(d=>{
        const data=d.data();
        if (containsSlur(data.text||'') || containsSlur(data.name||'')) {
          // If I'm a mod, delete. Otherwise just show grouped list without showing slur (safety).
          if (isMod(user.uid, user.email)) deleteDoc(doc(db,'rooms',ROOM_ID,'messages',d.id));
          // Always flag for review (once)
          addDoc(flagsColl, { uid: data.uid, name: data.name||'', email:'', text: data.text||'', reason:'slur (autoscan)', msgId:d.id, deviceId:'', at: serverTimestamp() }).catch(()=>{});
          return; // don't render
        }
        renderMessage(d, user.uid);
      });
      scrollToBottom();
    });

    // send handler with client-side automod (block + flag + escalate)
    form.onsubmit = async (e)=>{
      e.preventDefault();
      const text=input.value.trim();
      if(!text || text.length>MAX_LEN) return;
      if(sendingDisabledByBan || isRateLimited()){ updateCounter(); return; }

      const myName = user.displayName || 'Anon';
      if (containsSlur(text) || containsSlur(myName)) {
        // Block send, flag, escalate mute
        await flagAndEscalate(user.uid, myName, user.email, text, 'slur (blocked before send)', null);
        input.value=''; updateCounter();
        return;
      }

      await addDoc(msgsRef,{ uid:user.uid, name:myName, text, ts:serverTimestamp() });
      noteSent(); input.value=''; updateCounter(); scrollToBottom();
    };
  });

  // ---------- Username onboarding ----------
  unameForm.addEventListener('submit', async (e)=>{
    e.preventDefault();
    const username=(unameInput.value||'').trim().toLowerCase();
    if(!/^[a-z0-9_]{3,20}$/i.test(username)){ if(authMsg) authMsg.textContent='Use 3â€“20 chars: aâ€“z, 0â€“9, _'; return; }
    try{ await claimUsernameTx(username,auth.currentUser.uid); await updateProfile(auth.currentUser,{displayName:username}); await setDoc(doc(db,'users',auth.currentUser.uid),{username,lastUpdated:serverTimestamp()},{merge:true}); unamePane.style.display='none'; if(authMsg) authMsg.textContent='Username saved!'; paintHeaderCrown(); }
    catch(err){ if(authMsg) authMsg.textContent=err.message||String(err); }
  });

  // keep UI fresh
  setInterval(updateCounter,300);
</script>
</body>
</html>
