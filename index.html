<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Global Chat — Chat + DMs + Friends + Settings</title>
<style>
  :root{
    --bg-dark:#0b0f14; --card-dark:#121922; --muted:#8aa0b3; --border:#1e2a36;
    --accent:#4da3ff; --gold:#f5c542; --danger:#ff6b6b;
    --bg-light:#f6f8fb; --card-light:#ffffff; --text-light:#0b1620;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font:16px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:1200px;margin:20px auto;padding:0 16px}
  header{display:flex;gap:12px;align-items:center;margin:12px 0}
  h1{margin:0;font-size:22px}
  .pill{border:1px solid var(--border);border-radius:999px;padding:4px 10px;font-size:12px;background:var(--card)}
  .tabs{display:flex;gap:8px;margin-left:12px}
  .tab{padding:6px 10px;border-radius:999px;border:1px solid var(--border);cursor:pointer}
  .tab.active{background:rgba(255,255,255,0.03)}
  .row{display:flex;gap:16px;flex-wrap:wrap}
  .card{flex:1;min-width:280px;background:var(--card);border:1px solid var(--border);border-radius:12px;padding:12px}

  /* chat area */
  #messages{height:56vh;display:flex;flex-direction:column;gap:10px;scroll-behavior:smooth;padding-right:6px;overflow-y:auto;overflow-x:hidden}
  .msg{display:flex;position:relative}
  .bubble{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:8px 10px;max-width:80%;word-break:break-word;overflow-wrap:anywhere}
  .me .bubble{background:linear-gradient(180deg, rgba(11,32,54,1), rgba(10,30,50,1))}
  .name{font-weight:700;display:flex;align-items:center;gap:8px}
  .crown{color:var(--gold)}
  .text{white-space:pre-wrap}
  .ts{color:var(--muted);font-size:12px;margin-top:6px}
  .menu-btn{position:absolute;top:6px;right:6px;background:var(--card);border:1px solid var(--border);border-radius:8px;padding:2px 6px;cursor:pointer;font-size:12px}
  .menu{position:absolute;top:28px;right:6px;background:var(--card);border:1px solid var(--border);border-radius:10px;padding:6px;display:none;z-index:5;min-width:220px}
  .menu button{width:100%;text-align:left;padding:8px;border-radius:8px;border:1px solid var(--border);background:transparent;color:inherit;cursor:pointer;margin:4px 0}
  .menu button.danger{color:var(--danger)}

  .grouped .name{display:none}
  .grouped .bubble{margin-top:-6px}
  .group-start .bubble{margin-top:0}

  /* input */
  .row-input{display:flex;gap:10px;margin-top:10px;align-items:stretch}
  textarea{flex:1;min-height:46px;max-height:160px;resize:vertical;padding:10px;border-radius:8px;border:1px solid var(--border);background:transparent;color:inherit}
  button{padding:10px 14px;border-radius:8px;border:1px solid var(--border);background:transparent;color:inherit;cursor:pointer}
  button[disabled]{opacity:.5;cursor:not-allowed}
  .below{display:flex;justify-content:space-between;align-items:center;margin-top:8px}
  .tiny{font-size:12px;color:var(--muted)}
  .right{margin-left:auto;display:flex;gap:8px;align-items:center}

  /* side column lists */
  .side-list{display:flex;flex-direction:column;gap:8px}
  .item{padding:8px;border-radius:8px;border:1px solid var(--border);background:transparent;display:flex;justify-content:space-between;align-items:center}
  .badge{background:var(--accent);padding:4px 8px;border-radius:999px;color:#fff;font-size:12px}

  /* dm area */
  #dmList{max-height:28vh;overflow:auto;display:flex;flex-direction:column;gap:6px}
  #dmThread{max-height:44vh;overflow:auto;padding:8px;display:flex;flex-direction:column;gap:8px}

  /* friends */
  .friend-actions{display:flex;gap:6px}

  /* settings */
  .setting{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;border:1px solid var(--border);margin-top:8px}

  /* theme light/dark vars default -> dark */
  :root { --bg:var(--bg-dark); --card:var(--card-dark); --text:#e6eef6; }
  body.light { --bg:var(--bg-light); --card:var(--card-light); --text:var(--text-light); --border:#e0e6ee; --muted:#6b7280; }
  body{background:var(--bg)}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Global Chat</h1>
    <div class="tabs" id="mainTabs">
      <div class="tab active" data-tab="chat">Chat</div>
      <div class="tab" data-tab="dms">Direct Messages <span id="dmBadge" style="margin-left:6px"></span></div>
      <div class="tab" data-tab="friends">Friends</div>
      <div class="tab" data-tab="settings">Settings</div>
    </div>
    <div class="right">
      <span class="pill">auth: <span id="auth-state">loading…</span></span>
      <span class="pill">rt: <span id="rt-state">idle</span></span>
      <span id="whoami" class="pill" style="display:none;margin-left:8px"></span>
      <button id="signoutBtn" style="display:none;margin-left:6px">Sign out</button>
    </div>
  </header>

  <div class="row">
    <!-- Main chat column -->
    <div id="chatCol" class="card" style="flex:2">
      <!-- Chat view -->
      <div id="view-chat">
        <div id="messages"></div>

        <form id="form" class="row-input">
          <textarea id="input" placeholder="Write a message…" maxlength="500"></textarea>
          <button id="sendBtn" type="submit" disabled>Send</button>
        </form>

        <div class="below">
          <div class="tiny" id="counter">0 / 500</div>
          <div class="tiny right">
            <div id="throttleMsg"></div>
          </div>
        </div>
        <div class="tiny" id="banNotice" style="margin-top:8px;color:var(--danger)"></div>
      </div>

      <!-- DM view -->
      <div id="view-dms" style="display:none">
        <div style="display:flex;gap:10px">
          <div style="flex:1">
            <div style="font-weight:700;margin-bottom:6px">Conversations</div>
            <div id="dmList"></div>
          </div>
          <div style="flex:2;display:flex;flex-direction:column">
            <div style="display:flex;justify-content:space-between;align-items:center">
              <div style="font-weight:700" id="dmHeader">Select conversation</div>
              <div><button id="newConvBtn" style="display:none">New DM</button></div>
            </div>
            <div id="dmThread" class="card" style="flex:1;margin-top:8px;min-height:220px"></div>

            <form id="dmForm" class="row-input" style="margin-top:8px;display:none">
              <textarea id="dmInput" placeholder="Write a private message…" maxlength="1000"></textarea>
              <button id="dmSend" type="submit">Send DM</button>
            </form>
          </div>
        </div>
      </div>

      <!-- Friends view -->
      <div id="view-friends" style="display:none">
        <div style="display:flex;gap:12px">
          <div style="flex:1">
            <div style="display:flex;justify-content:space-between;align-items:center">
              <div style="font-weight:700">Friends</div>
            </div>
            <div id="friendsList" style="margin-top:8px"></div>
          </div>

          <div style="flex:1">
            <div style="display:flex;gap:8px">
              <div class="tab active" id="ftab-friends">Friends</div>
              <div class="tab" id="ftab-requests">Requests</div>
              <div class="tab" id="ftab-sent">Sent</div>
            </div>
            <div id="friendsTabContent" style="margin-top:8px"></div>
          </div>
        </div>
      </div>

      <!-- Settings view -->
      <div id="view-settings" style="display:none">
        <div style="font-weight:700">Settings</div>
        <div class="setting">
          <div>Theme</div>
          <div><button id="themeToggle">Toggle theme</button></div>
        </div>
        <div class="setting">
          <div>Allow DMs from non-friends</div>
          <div><input type="checkbox" id="allowDMToggle"></div>
        </div>
        <div class="setting">
          <div>Censor swears/slurs (client only)</div>
          <div><input type="checkbox" id="censorToggle"></div>
        </div>
        <div class="setting">
          <div>Show DMs unread badge</div>
          <div><input type="checkbox" id="dmBadgeToggle" checked></div>
        </div>
        <div style="margin-top:12px">
          <div style="font-weight:700">Blocked users (local)</div>
          <div id="blockedList" style="margin-top:8px"></div>
        </div>
      </div>
    </div>

    <!-- Side column (auth/mod/tools) -->
    <div id="sideCol" class="card" style="flex:1">
      <div id="authArea">
        <button id="googleBtn" style="width:100%;margin-bottom:10px">Continue with Google</button>
        <div style="display:flex;gap:8px">
          <div class="tab active" id="signinTab">Sign in</div>
          <div class="tab" id="signupTab">Sign up</div>
        </div>

        <div id="signinPane" style="margin-top:8px">
          <form id="signinForm">
            <input id="si-email" type="email" placeholder="Email" required style="width:100%;padding:8px;border-radius:6px;margin-bottom:6px;border:1px solid var(--border);background:transparent;color:inherit">
            <input id="si-pass" type="password" placeholder="Password" required style="width:100%;padding:8px;border-radius:6px;margin-bottom:6px;border:1px solid var(--border);background:transparent;color:inherit">
            <button style="width:100%">Sign in</button>
          </form>
        </div>

        <div id="signupPane" style="margin-top:8px;display:none">
          <form id="signupForm">
            <input id="su-username" placeholder="Username (a–z, 0–9, _)" minlength="3" maxlength="20" required style="width:100%;padding:8px;border-radius:6px;margin-bottom:6px;border:1px solid var(--border);background:transparent;color:inherit">
            <input id="su-email" type="email" placeholder="Email" required style="width:100%;padding:8px;border-radius:6px;margin-bottom:6px;border:1px solid var(--border);background:transparent;color:inherit">
            <input id="su-pass" type="password" placeholder="Password (min 6 chars)" minlength="6" required style="width:100%;padding:8px;border-radius:6px;margin-bottom:6px;border:1px solid var(--border);background:transparent;color:inherit">
            <button style="width:100%">Create account</button>
          </form>
        </div>

        <div id="usernameOnboard" style="display:none;margin-top:8px">
          <form id="unameForm">
            <input id="uname-input" placeholder="Pick a username" minlength="3" maxlength="20" style="width:100%;padding:8px;border-radius:6px;border:1px solid var(--border);background:transparent;color:inherit">
            <button style="width:100%;margin-top:6px">Save username</button>
          </form>
        </div>
        <div id="authMsg" style="margin-top:8px;color:var(--muted)"></div>
      </div>

      <div id="modPanel" style="display:none;margin-top:12px">
        <div style="font-weight:700">Moderation</div>
        <div style="margin-top:8px">
          <div style="font-weight:600">Muted/Banned</div>
          <div id="modBans" style="margin-top:6px"></div>
        </div>
        <div style="margin-top:12px">
          <div style="font-weight:600">Flagged</div>
          <div id="modFlags" style="margin-top:6px"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<script type="module">
/* ========= Firebase SDKs ========= */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
import {
  getAuth, onAuthStateChanged, signOut,
  createUserWithEmailAndPassword, signInWithEmailAndPassword, updateProfile,
  GoogleAuthProvider, signInWithPopup, signInWithRedirect, getRedirectResult, linkWithPopup
} from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";
import {
  getFirestore, doc, setDoc, getDoc, collection, addDoc, runTransaction,
  serverTimestamp, query, orderBy, limit, onSnapshot, deleteDoc, getDocs, where
} from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

/* ========= Config (your keys) ========= */
const firebaseConfig = {
  apiKey: "AIzaSyD782fUtLrYCszRZhXIi9jBpZEDjDtZrcw",
  authDomain: "poopy-games-chat.firebaseapp.com",
  projectId: "poopy-games-chat",
  storageBucket: "poopy-games-chat.firebasestorage.app",
  messagingSenderId: "412556849195",
  appId: "1:412556849195:web:643791cd55e173f9fbba6e",
  measurementId: "G-ELSV57GKEP"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);

/* ========= DOM refs ========= */
const tabs = document.querySelectorAll('#mainTabs .tab');
const dmBadgeEl = document.getElementById('dmBadge');

const viewChat = document.getElementById('view-chat');
const viewDMs = document.getElementById('view-dms');
const viewFriends = document.getElementById('view-friends');
const viewSettings = document.getElementById('view-settings');

const messagesEl = document.getElementById('messages');
const form = document.getElementById('form');
const input = document.getElementById('input');
const sendBtn = document.getElementById('sendBtn');
const counterEl = document.getElementById('counter');
const throttleMsg = document.getElementById('throttleMsg');
const banNotice = document.getElementById('banNotice');

const sideCol = document.getElementById('sideCol');
const authArea = document.getElementById('authArea');
const authState = document.getElementById('auth-state');
const rtState = document.getElementById('rt-state');
const whoami = document.getElementById('whoami');
const signoutBtn = document.getElementById('signoutBtn');

const googleBtn = document.getElementById('googleBtn');
const signinTab = document.getElementById('signinTab');
const signupTab = document.getElementById('signupTab');
const signinPane = document.getElementById('signinPane');
const signupPane = document.getElementById('signupPane');
const authMsg = document.getElementById('authMsg');
const usernameOnboard = document.getElementById('usernameOnboard');

const dmListEl = document.getElementById('dmList');
const dmThreadEl = document.getElementById('dmThread');
const dmForm = document.getElementById('dmForm');
const dmInput = document.getElementById('dmInput');
const dmHeader = document.getElementById('dmHeader');

const friendsList = document.getElementById('friendsList');
const friendsTabContent = document.getElementById('friendsTabContent');
const ftabFriends = document.getElementById('ftab-friends');
const ftabRequests = document.getElementById('ftab-requests');
const ftabSent = document.getElementById('ftab-sent');

const modPanel = document.getElementById('modPanel');
const modBans = document.getElementById('modBans');
const modFlags = document.getElementById('modFlags');

const allowDMToggle = document.getElementById('allowDMToggle');
const censorToggle = document.getElementById('censorToggle');
const themeToggle = document.getElementById('themeToggle');
const dmBadgeToggle = document.getElementById('dmBadgeToggle');

const blockedListEl = document.getElementById('blockedList');
const unameForm = document.getElementById('unameForm');
const unameInput = document.getElementById('uname-input');

/* ========= constants & refs ========= */
const ROOM_ID = 'global';
const SUPERADMIN_UID = 'clkCiJePNvaWecDuoTEmqSMohim2';
const MAX_LEN = 500;
const GROUP_WINDOW_MS = 5 * 60 * 1000;

const msgsRef = collection(db, 'rooms', ROOM_ID, 'messages');
const bansColl = collection(db, 'rooms', ROOM_ID, 'bans');
const modsColl = collection(db, 'rooms', ROOM_ID, 'mods');
const flagsColl = collection(db, 'rooms', ROOM_ID, 'flags');

const usersRoot = collection(db,'users');

/* ========= state ========= */
let currentUser = null;
let modUIDs = new Set();
let lastUid = null, lastTsMs = 0;
let sendingDisabledByBan = false;
let sendTimes = [], cooldownUntil = 0, lastSentAt = 0;
let blocked = ( () => { try { return new Set(JSON.parse(localStorage.getItem('blocked_uids')||'[]')); } catch { return new Set(); } })();
let deviceId = ( () => { let id = localStorage.getItem('device_id'); if(!id){ id = crypto.randomUUID(); localStorage.setItem('device_id', id);} return id; })();

let mySettings = { allowDMs: true, censor: false, theme: 'dark', showDmBadge: true };
let currentDMConv = null; // { id, otherUid, otherName }

/* ========= helpers ========= */
function setTheme(theme){ if(theme === 'light'){ document.body.classList.add('light'); } else { document.body.classList.remove('light'); } }
function updateCounter(){ const len = input.value.length; counterEl.textContent = `${len} / ${MAX_LEN}`; sendBtn.disabled = (len===0 || len>MAX_LEN || !auth.currentUser || isRateLimited() || sendingDisabledByBan); }
function isRateLimited(){ const now=Date.now(); while(sendTimes.length && now-sendTimes[0] > 2000) sendTimes.shift(); if(now < cooldownUntil){ const rem = Math.ceil((cooldownUntil-now)/1000); throttleMsg.textContent = `Slow mode: 1 msg/sec for ${rem}s`; if(now - lastSentAt < 1000) return true; return false; } throttleMsg.textContent=''; if(sendTimes.length>5){ cooldownUntil = now + 10000; throttleMsg.textContent='Slow mode: 1 msg/sec for 10s'; } return false; }
function noteSent(){ const n = Date.now(); sendTimes.push(n); lastSentAt = n; updateCounter(); }
function fmtTime(ts){ try{ return new Date(ts?.toMillis?.() ?? ts).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}); } catch { return ''; } }
function convIdFrom(u1,u2){ return [u1,u2].sort().join('_'); }

/* ========= AutoMod / slur handling ========= */
function normalizeText(s){
  return s.toLowerCase()
    .normalize('NFD').replace(/\p{Diacritic}/gu,'')
    .replace(/[@]/g,'a').replace(/0/g,'o').replace(/[1l!]/g,'i').replace(/3/g,'e').replace(/4/g,'a').replace(/5/g,'s').replace(/7/g,'t')
    .replace(/[^a-z0-9 ]+/g,' ')
    .replace(/(\w)\1{2,}/g,'$1$1')
    .replace(/\s+/g,' ').trim();
}
const SLURS = ['nigger','nigga','chink','spic','faggot','retard','tranny','kike','wetback'];
const SLUR_RE = new RegExp(`\\b(${SLURS.map(x=>x.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')).join('|')})\\b`,'i');
function containsSlur(s){ return SLUR_RE.test(normalizeText(s||'')); }
function censorText(s){ return s.replace(SLUR_RE, (m)=>'*'.repeat(Math.max(1,m.length))); }

/* ========= UI helpers ========= */
function switchTab(tab){
  document.querySelectorAll('#mainTabs .tab').forEach(t=>t.classList.toggle('active', t.dataset.tab === tab));
  viewChat.style.display = tab === 'chat' ? '' : 'none';
  viewDMs.style.display = tab === 'dms' ? '' : 'none';
  viewFriends.style.display = tab === 'friends' ? '' : 'none';
  viewSettings.style.display = tab === 'settings' ? '' : 'none';
  if(tab === 'dms') loadDMConversations();
  if(tab === 'friends') loadFriendsPanel();
}
document.querySelectorAll('#mainTabs .tab').forEach(t=>t.addEventListener('click', ()=> switchTab(t.dataset.tab)));

function renderBlockedList(){
  blockedListEl.innerHTML = '';
  if(blocked.size === 0) { blockedListEl.textContent = 'No locally blocked users'; return; }
  Array.from(blocked).forEach(uid=>{
    const el = document.createElement('div'); el.className='item';
    el.textContent = uid;
    const btn = document.createElement('button'); btn.textContent='Unblock (local)'; btn.onclick = ()=>{ blocked.delete(uid); localStorage.setItem('blocked_uids', JSON.stringify(Array.from(blocked))); renderBlockedList(); };
    el.appendChild(btn);
    blockedListEl.appendChild(el);
  });
}

/* ========= Public chat: menu & rendering ========= */
function makeUserMenu(docId, m){
  const wrap = document.createElement('div'); wrap.className='menu';
  const me = currentUser && currentUser.uid === m.uid;
  const amMod = currentUser && (modUIDs.has(currentUser.uid) || currentUser.email === SUPERADMIN_UID);

  function add(label, fn, danger=false){
    const b = document.createElement('button'); b.textContent = label; if(danger) b.classList.add('danger');
    b.onclick = async (e)=>{ e.stopPropagation(); wrap.style.display='none'; try{ await fn(); } catch(err){ alert('Action failed: '+(err.message||String(err))); console.error(err); } };
    wrap.appendChild(b);
  }

  if(me || amMod) add('Delete message', ()=> deleteDoc(doc(db,'rooms',ROOM_ID,'messages',docId)), true);
  add(blocked.has(m.uid) ? 'Unblock user (local)' : 'Block user (local)', ()=> { if(blocked.has(m.uid)) blocked.delete(m.uid); else blocked.add(m.uid); localStorage.setItem('blocked_uids', JSON.stringify(Array.from(blocked))); document.querySelectorAll(`[data-uid="${m.uid}"]`).forEach(el=>el.classList.toggle('collapsed', blocked.has(m.uid))); renderBlockedList(); });

  add('Send friend request', async ()=> {
    if(!currentUser){ alert('Sign in first'); return; }
    if(blocked.has(m.uid) || blocked.has(currentUser.uid)){ alert('Cannot send friend request (blocked)'); return; }
    if(currentUser.uid === m.uid){ alert("Can't friend yourself"); return; }
    // ensure target allows friend requests? (we assume allowed by default)
    await setDoc(doc(db,'users', m.uid, 'friendRequests', currentUser.uid), { from: currentUser.uid, fromName: currentUser.displayName || '', at: serverTimestamp(), status: 'pending' });
    alert('Friend request sent');
    loadFriendsPanel(); // refresh UI
  });

  add('DM', async ()=> {
    if(!currentUser){ alert('Sign in first'); return; }
    if(blocked.has(m.uid) || blocked.has(currentUser.uid)){ alert('Cannot DM (blocked)'); return; }
    const otherSnap = await getDoc(doc(db,'users', m.uid));
    const allow = otherSnap.exists() ? (otherSnap.data().allowDMs !== false) : true;
    if(!allow){ alert('User has DMs turned off'); return; }
    openDMWith(m.uid, m.name || m.username || m.uid);
  });

  if(amMod && m.uid){
    add('Mute…', async ()=> {
      const dur = prompt('Mute duration? (e.g., 10m, 1h, 1d)'); const ms = parseHumanDuration(dur);
      if(isNaN(ms)||ms<=0) { alert('Enter 10m, 1h, 1d'); return; }
      const reason = prompt('Reason (shown to user)') || '';
      await setDoc(doc(db,'rooms',ROOM_ID,'bans',m.uid), { muteUntil: new Date(Date.now()+ms), by: currentUser.email, reason, at: serverTimestamp() }, { merge:true });
    }, true);

    add('Ban…', async ()=> {
      const dur = prompt('Ban duration? (e.g., 1h, 1d, 7d)'); const ms = parseHumanDuration(dur);
      if(isNaN(ms)||ms<=0) { alert('Enter 1h, 1d, 7d'); return; }
      const reason = prompt('Reason (shown to user)') || '';
      await setDoc(doc(db,'rooms',ROOM_ID,'bans',m.uid), { banUntil: new Date(Date.now()+ms), perma:false, by: currentUser.email, reason, at: serverTimestamp() }, { merge:true });
    }, true);

    add('Perma-ban', async ()=> {
      if(!confirm('PERMANENT ban — continue?')) return;
      const reason = prompt('Reason (shown to user)') || '';
      await setDoc(doc(db,'rooms',ROOM_ID,'bans',m.uid), { perma:true, by: currentUser.email, reason, at: serverTimestamp() }, { merge:true });
    }, true);

    add('Unmute', ()=> setDoc(doc(db,'rooms',ROOM_ID,'bans',m.uid), { muteUntil: new Date(0) }, { merge:true }));
    add('Unban', ()=> setDoc(doc(db,'rooms',ROOM_ID,'bans',m.uid), { banUntil: new Date(0), perma:false }, { merge:true }));

    // grant/remove mod (owner protected by server rules)
    if(currentUser && m.uid && m.uid !== currentUser.uid){
      if(modUIDs.has(m.uid)){
        add('Remove moderator', async ()=> { await deleteDoc(doc(db,'rooms',ROOM_ID,'mods', m.uid)); });
      } else {
        add('Grant moderator', async ()=> { await setDoc(doc(db,'rooms',ROOM_ID,'mods', m.uid), { isMod: true, by: currentUser.uid, at: serverTimestamp() }); });
      }
    }
  }

  return wrap;
}

function renderPublicMessage(docSnap, myUid){
  const m = docSnap.data();
  const row = document.createElement('div');
  row.className = 'msg';
  row.dataset.uid = m.uid || '';
  if(m.uid === myUid) row.classList.add('me');

  const bubble = document.createElement('div'); bubble.className = 'bubble';
  const name = document.createElement('div'); name.className='name';
  const label = document.createElement('span'); label.textContent = m.name || m.username || 'Anon';
  name.appendChild(label);
  if(m.uid && modUIDs.has(m.uid)){ const cr = document.createElement('span'); cr.className='crown'; cr.textContent=' 👑'; name.appendChild(cr); }

  let textToShow = m.text || '';
  if(mySettings.censor) textToShow = censorText(textToShow);
  const text = document.createElement('div'); text.className='text'; text.textContent = textToShow;
  const ts = document.createElement('div'); ts.className='ts'; ts.textContent = fmtTime(m.ts);

  const menuBtn = document.createElement('div'); menuBtn.className='menu-btn'; menuBtn.textContent='⋯';
  const menu = makeUserMenu(docSnap.id, m);
  menuBtn.onclick = (e) => { e.stopPropagation(); menu.style.display = (menu.style.display === 'block' ? 'none' : 'block'); };
  document.addEventListener('click', ()=> { menu.style.display = 'none'; });

  bubble.appendChild(name); bubble.appendChild(text); bubble.appendChild(ts);
  row.appendChild(bubble); row.appendChild(menuBtn); row.appendChild(menu);

  if(blocked.has(m.uid)) row.classList.add('collapsed');

  // grouping
  const tsMs = m.ts?.toMillis?.() ?? Date.now();
  const grouped = (lastUid === m.uid) && (tsMs - lastTsMs <= GROUP_WINDOW_MS);
  row.classList.toggle('grouped', grouped);
  row.classList.toggle('group-start', !grouped);
  lastUid = m.uid; lastTsMs = tsMs;

  messagesEl.appendChild(row);
}

/* ========= DM system ========= */
async function openDMWith(otherUid, otherName){
  const me = auth.currentUser;
  if(!me){ alert('Sign in first'); return; }
  if(blocked.has(otherUid) || blocked.has(me.uid)){ alert('Cannot DM (blocked)'); return; }
  const otherSnap = await getDoc(doc(db,'users',otherUid));
  const allow = otherSnap.exists() ? (otherSnap.data().allowDMs !== false) : true;
  if(!allow){ alert('User has DMs turned off'); return; }

  const id = convIdFrom(me.uid, otherUid);
  currentDMConv = { id, otherUid, otherName: otherName || (otherSnap.data()?.username || otherUid) };
  dmHeader.textContent = `DM — ${currentDMConv.otherName}`;
  dmForm.style.display = '';
  dmInput.value = '';
  dmThreadEl.innerHTML = '';

  // Listen to messages in /dms/{id}/messages ordered asc
  const msgsQuery = query(collection(db,'dms', id, 'messages'), orderBy('ts','asc'), limit(500));
  onSnapshot(msgsQuery, (snap)=>{
    dmThreadEl.innerHTML = '';
    snap.forEach(d=>{
      const data = d.data();
      let txt = data.text || '';
      // apply client-only censor
      if(mySettings.censor) txt = censorText(txt);
      const mdiv = document.createElement('div');
      mdiv.className = 'item';
      mdiv.style.textAlign = data.senderId === me.uid ? 'right' : 'left';
      mdiv.textContent = `${data.senderName || data.senderId}: ${txt} (${fmtTime(data.ts)})`;
      dmThreadEl.appendChild(mdiv);
    });
    dmThreadEl.scrollTop = dmThreadEl.scrollHeight;
  });

  // ensure conversation indexed on both users (so they show in conversation list)
  await setDoc(doc(db,'users', me.uid, 'dms', id), { with: otherUid, at: serverTimestamp() }, { merge:true });
  await setDoc(doc(db,'users', otherUid, 'dms', id), { with: me.uid, at: serverTimestamp() }, { merge:true });

  switchTab('dms');
}

dmForm.addEventListener('submit', async (e)=>{
  e.preventDefault();
  if(!currentUser || !currentDMConv){ alert('No conversation'); return; }
  const text = dmInput.value.trim();
  if(!text) return;
  if(blocked.has(currentDMConv.otherUid) || blocked.has(currentUser.uid)){ alert('Cannot DM (blocked)'); return; }
  const otherSnap = await getDoc(doc(db,'users', currentDMConv.otherUid));
  const allow = otherSnap.exists() ? (otherSnap.data().allowDMs !== false) : true;
  if(!allow){ alert('User has DMs turned off'); return; }

  // client-side automod for DMs: if slur, block send and flag (we won't store slurs in DMs)
  if(containsSlur(text) || containsSlur(currentUser.displayName || '')){
    await flagAndEscalate(currentUser.uid, currentUser.displayName || '', currentUser.email || '', text, 'slur in DM (blocked)', null);
    dmInput.value = '';
    return;
  }

  const id = currentDMConv.id;
  const msgsCol = collection(db,'dms', id, 'messages');
  await addDoc(msgsCol, { senderId: currentUser.uid, senderName: currentUser.displayName || '', receiverId: currentDMConv.otherUid, text, ts: serverTimestamp() });

  // ensure both users have the conv indexed
  await setDoc(doc(db,'users', currentUser.uid, 'dms', id), { with: currentDMConv.otherUid, at: serverTimestamp() }, { merge:true });
  await setDoc(doc(db,'users', currentDMConv.otherUid, 'dms', id), { with: currentUser.uid, at: serverTimestamp() }, { merge:true });

  dmInput.value = '';
});

/* ========= Friend system UI ========= */
async function loadFriendsPanel(){
  friendsTabContent.innerHTML = '';
  if(!currentUser){ friendsTabContent.textContent = 'Sign in to manage friends'; return; }
  // default show Friends subtab
  showFriendsSubtab('friends');
}

ftabFriends.addEventListener('click', ()=> showFriendsSubtab('friends'));
ftabRequests.addEventListener('click', ()=> showFriendsSubtab('requests'));
ftabSent.addEventListener('click', ()=> showFriendsSubtab('sent'));

async function showFriendsSubtab(which){
  ftabFriends.classList.toggle('active', which==='friends');
  ftabRequests.classList.toggle('active', which==='requests');
  ftabSent.classList.toggle('active', which==='sent');
  friendsTabContent.innerHTML = '';
  if(!currentUser) { friendsTabContent.textContent = 'Sign in to manage friends'; return; }

  if(which === 'friends'){
    const snap = await getDocs(collection(db,'users', currentUser.uid, 'friends'));
    if(snap.empty){ friendsTabContent.textContent = 'No friends yet'; return; }
    snap.forEach(d=>{
      const el = document.createElement('div'); el.className='item';
      el.textContent = d.id;
      const btns = document.createElement('div'); btns.className='friend-actions';
      const dmBtn = document.createElement('button'); dmBtn.textContent='DM'; dmBtn.onclick = ()=> openDMWith(d.id, d.id);
      const unfriend = document.createElement('button'); unfriend.textContent='Unfriend'; unfriend.onclick = async ()=>{
        await deleteDoc(doc(db,'users', currentUser.uid, 'friends', d.id));
        await deleteDoc(doc(db,'users', d.id, 'friends', currentUser.uid));
        showFriendsSubtab('friends');
      };
      btns.append(dmBtn, unfriend);
      el.appendChild(btns);
      friendsTabContent.appendChild(el);
    });
  } else if(which === 'requests'){
    // incoming requests under /users/{me}/friendRequests
    const snap = await getDocs(collection(db,'users', currentUser.uid, 'friendRequests'));
    if(snap.empty){ friendsTabContent.textContent = 'No incoming requests'; return; }
    snap.forEach(d=>{
      const data = d.data();
      const el = document.createElement('div'); el.className='item';
      el.textContent = `${data.fromName || data.from} (${d.id})`;
      const accept = document.createElement('button'); accept.textContent='Accept'; accept.onclick = async ()=>{
        // create friendship under both users and delete request
        await setDoc(doc(db,'users', currentUser.uid, 'friends', d.id), { at: serverTimestamp() }, { merge:true });
        await setDoc(doc(db,'users', d.id, 'friends', currentUser.uid), { at: serverTimestamp() }, { merge:true });
        await deleteDoc(doc(db,'users', currentUser.uid, 'friendRequests', d.id));
        showFriendsSubtab('requests');
      };
      const decline = document.createElement('button'); decline.textContent='Decline'; decline.onclick = async ()=>{
        await deleteDoc(doc(db,'users', currentUser.uid, 'friendRequests', d.id));
        showFriendsSubtab('requests');
      };
      const block = document.createElement('button'); block.textContent='Block (local)'; block.onclick = ()=> { blocked.add(d.id); localStorage.setItem('blocked_uids', JSON.stringify(Array.from(blocked))); renderBlockedList(); };
      const actions = document.createElement('div'); actions.className='friend-actions';
      actions.append(accept, decline, block);
      el.appendChild(actions);
      friendsTabContent.appendChild(el);
    });
  } else if(which === 'sent'){
    // outgoing: they are stored in targets as /users/{target}/friendRequests/{myUid}
    // to list outgoing, we scan users for docs referencing currentUser? That's heavy.
    // Instead we maintain index: /users/{me}/sentRequests/{targetUid}
    const snap = await getDocs(collection(db,'users', currentUser.uid, 'sentRequests'));
    if(snap.empty){ friendsTabContent.textContent = 'No sent requests'; return; }
    snap.forEach(d=>{
      const el = document.createElement('div'); el.className='item';
      el.textContent = d.id;
      const cancel = document.createElement('button'); cancel.textContent='Cancel'; cancel.onclick = async ()=>{
        await deleteDoc(doc(db,'users', currentUser.uid, 'sentRequests', d.id));
        // also delete receiver's incoming request if present
        await deleteDoc(doc(db,'users', d.id, 'friendRequests', currentUser.uid));
        showFriendsSubtab('sent');
      };
      el.appendChild(cancel);
      friendsTabContent.appendChild(el);
    });
  }
}

/* ========= Settings handling ========= */
async function loadMySettings(){
  if(!currentUser) return;
  const snap = await getDoc(doc(db,'users', currentUser.uid));
  if(snap.exists()){
    const d = snap.data();
    mySettings.allowDMs = d.allowDMs !== false;
    mySettings.censor = d.censor === true;
    mySettings.theme = d.theme || 'dark';
    mySettings.showDmBadge = d.showDmBadge !== false;
  } else {
    mySettings = { allowDMs: true, censor:false, theme:'dark', showDmBadge:true };
    await setDoc(doc(db,'users', currentUser.uid), { allowDMs: true, censor:false, theme:'dark', showDmBadge:true }, { merge:true });
  }
  allowDMToggle.checked = mySettings.allowDMs;
  censorToggle.checked = mySettings.censor;
  dmBadgeToggle.checked = mySettings.showDmBadge;
  setTheme(mySettings.theme);
}

allowDMToggle.addEventListener('change', async ()=>{
  if(!currentUser) return;
  mySettings.allowDMs = allowDMToggle.checked;
  await setDoc(doc(db,'users', currentUser.uid), { allowDMs: mySettings.allowDMs }, { merge:true });
});
censorToggle.addEventListener('change', async ()=>{
  if(!currentUser) return;
  mySettings.censor = censorToggle.checked;
  await setDoc(doc(db,'users', currentUser.uid), { censor: mySettings.censor }, { merge:true });
});
dmBadgeToggle.addEventListener('change', async ()=>{
  if(!currentUser) return;
  mySettings.showDmBadge = dmBadgeToggle.checked;
  await setDoc(doc(db,'users', currentUser.uid), { showDmBadge: mySettings.showDmBadge }, { merge:true });
});
themeToggle.addEventListener('click', async ()=>{
  mySettings.theme = (mySettings.theme === 'dark') ? 'light' : 'dark';
  setTheme(mySettings.theme);
  if(currentUser) await setDoc(doc(db,'users', currentUser.uid), { theme: mySettings.theme }, { merge:true });
});

/* ========= Signup / Signin / Google ========= */
signinTab.onclick = ()=> { signinPane.style.display='block'; signupPane.style.display='none'; };
signupTab.onclick = ()=> { signupPane.style.display='block'; signinPane.style.display='none'; };

document.getElementById('signupForm').addEventListener('submit', async (e)=>{
  e.preventDefault();
  const username = document.getElementById('su-username').value.trim().toLowerCase();
  const email = document.getElementById('su-email').value.trim();
  const pass = document.getElementById('su-pass').value;
  if(!/^[a-z0-9_]{3,20}$/.test(username)){ authMsg.textContent='Username: 3–20 chars a–z 0–9 _'; return; }
  try {
    const cred = await createUserWithEmailAndPassword(auth, email, pass);
    await claimUsernameTx(username, cred.user.uid);
    await updateProfile(cred.user, { displayName: username });
    await setDoc(doc(db,'users',cred.user.uid), { username, email, deviceId, allowDMs:true, censor:false, theme:'dark', showDmBadge:true, createdAt:serverTimestamp() }, { merge:true });
    authMsg.textContent = 'Account created and signed in';
  } catch(err){
    authMsg.textContent = err.message || String(err);
  }
});

document.getElementById('signinForm').addEventListener('submit', async (e)=>{
  e.preventDefault();
  const email = document.getElementById('si-email').value.trim();
  const pass = document.getElementById('si-pass').value;
  try { await signInWithEmailAndPassword(auth, email, pass); authMsg.textContent = 'Signed in'; }
  catch(err){ authMsg.textContent = err.message || String(err); }
});

const provider = new GoogleAuthProvider();
googleBtn.onclick = async ()=> {
  try { if(auth.currentUser) await linkWithPopup(auth.currentUser, provider); else await signInWithPopup(auth, provider); authMsg.textContent=''; }
  catch(err){ try{ authMsg.textContent=(err.code||'')+' — trying redirect…'; await signInWithRedirect(auth, provider); } catch(err2){ authMsg.textContent = err2.message || String(err2); } }
};
getRedirectResult(auth).catch(err => { if(err) authMsg.textContent = err.message || String(err); });

/* ========= Username registry claim ========= */
async function claimUsernameTx(username, uid){
  const uname = username.toLowerCase();
  const unameRef = doc(db,'usernames', uname);
  await runTransaction(db, async (tx)=>{
    const snap = await tx.get(unameRef);
    if(snap.exists()) throw new Error('Username already taken');
    tx.set(unameRef, { uid, at: serverTimestamp() });
  });
}

/* ========= Moderation / AutoMod helpers ========= */
async function setMute(uid, ms, reason){
  const until = ms>0 ? new Date(Date.now()+ms) : new Date(0);
  await setDoc(doc(db,'rooms',ROOM_ID,'bans', uid), { muteUntil: until, by: currentUser.email, at: serverTimestamp(), reason }, { merge:true });
}
async function flagAndEscalate(uid, name, email, text, reason, msgId=null){
  await addDoc(flagsColl, { uid, name, email: email||'', text, reason, msgId: msgId||'', deviceId, at: serverTimestamp() });
  const ref = doc(db,'rooms', ROOM_ID, 'automod', uid);
  const snap = await getDoc(ref);
  const now = Date.now();
  let strikes = 0, last = 0;
  if(snap.exists()){ strikes = snap.data().strikes || 0; last = snap.data().lastAt?.toMillis?.() || 0; }
  if(now - last > 24*3600*1000) strikes = 0;
  strikes += 1;
  const ladder = [60e3, 5*60e3, 10*60e3, 20*60e3, 3600e3, 6*3600e3, 86400e3*7, 86400e3*21, 86400e3*42];
  const muteMs = ladder[Math.min(strikes-1, ladder.length-1)];
  await setDoc(ref, { strikes, lastAt: serverTimestamp() }, { merge:true });
  await setMute(uid, muteMs, `AutoMod slur (strike ${strikes})`);
}

/* ========= Public chat: listener & send ========= */
function startPublicListener(myUid){
  const q = query(msgsRef, orderBy('ts','asc'), limit(500));
  onSnapshot(q, (snap) => {
    messagesEl.innerHTML = '';
    lastUid = null; lastTsMs = 0;
    snap.forEach(d => {
      const m = d.data();
      if(containsSlur(m.text || '') || containsSlur(m.name || '')){
        if(currentUser && (modUIDs.has(currentUser.uid) || currentUser.uid === SUPERADMIN_UID)){
          deleteDoc(doc(db,'rooms',ROOM_ID,'messages', d.id)).catch(()=>{});
        }
        if(currentUser) addDoc(flagsColl, { uid: m.uid, name: m.name || '', email: currentUser.email || '', text: m.text || '', reason: 'slur (autoscan)', msgId: d.id, at: serverTimestamp() }).catch(()=>{});
        return;
      }
      renderPublicMessage(d, myUid);
    });
    messagesEl.scrollTop = messagesEl.scrollHeight;
  }, (err) => { console.error('messages onSnapshot error', err); });
}

form.addEventListener('submit', async (e)=>{
  e.preventDefault();
  if(!currentUser){ alert('Sign in first'); return; }
  const text = input.value.trim();
  if(!text || text.length > MAX_LEN) return;
  if(sendingDisabledByBan || isRateLimited()){ updateCounter(); return; }

  if(containsSlur(text) || containsSlur(currentUser.displayName || '')){
    await flagAndEscalate(currentUser.uid, currentUser.displayName || '', currentUser.email || '', text, 'slur (blocked before send)', null);
    input.value = ''; updateCounter(); return;
  }

  await addDoc(msgsRef, { uid: currentUser.uid, name: currentUser.displayName || 'Anon', text, ts: serverTimestamp() });
  noteSent(); input.value=''; updateCounter(); messagesEl.scrollTop = messagesEl.scrollHeight;
});

/* ========= Mods watchers (crowns + my mod doc to avoid reload loops) ========= */
function watchModsList(){
  onSnapshot(modsColl, (snap)=>{
    const s = new Set(); snap.forEach(d=> s.add(d.id));
    modUIDs = s;
    paintHeader();
  });
}
let myModCached = null;
function watchMyModDoc(uid){
  if(!uid) return;
  const ref = doc(db,'rooms',ROOM_ID,'mods', uid);
  onSnapshot(ref, (snap)=>{
    const nowIs = snap.exists();
    if(myModCached === null){ myModCached = nowIs; return; }
    if(nowIs !== myModCached){ myModCached = nowIs; location.reload(); }
  });
}
function paintHeader(){
  if(!currentUser) return;
  const crown = (modUIDs.has(currentUser.uid) || currentUser.uid === SUPERADMIN_UID) ? ' 👑' : '';
  whoami.style.display = 'inline-block';
  whoami.textContent = `@${currentUser.displayName || 'user'} · ${currentUser.email || ''}${crown}`;
}

/* ========= utility functions ========= */
function parseHumanDuration(s){ if(!s) return 0; const m = String(s).trim().match(/^(\d+)\s*([mhd])$/i); if(!m) return NaN; const v = +m[1], u = m[2].toLowerCase(); return u==='m'?v*60*1000:u==='h'?v*3600*1000:v*24*3600*1000; }
function updateDmBadge(count){ if(!mySettings.showDmBadge) { dmBadgeEl.textContent = ''; return; } if(!count) { dmBadgeEl.textContent = ''; return; } dmBadgeEl.innerHTML = `<span class="badge">${count}</span>`; }
async function refreshDmBadge(){ if(!currentUser) { updateDmBadge(0); return; } const snaps = await getDocs(collection(db,'users', currentUser.uid, 'dms')); updateDmBadge(snaps.size); }

/* ========= Auth state handling ========= */
onAuthStateChanged(auth, async (user) => {
  currentUser = user || null;
  if(!user){
    authState.textContent = 'signed out';
    whoami.style.display = 'none';
    signoutBtn.style.display = 'none';
    authArea.style.display = '';
    sideCol.style.display = '';
    modPanel.style.display = 'none';
    updateCounter();
    startPublicListener(null);
    return;
  }

  authState.textContent = 'signed in';
  authArea.style.display = 'none';
  signoutBtn.style.display = '';
  // attach device id & ensure user doc
  await setDoc(doc(db,'users', user.uid), { email: user.email || '', username: user.displayName || '', deviceId, lastSeen: serverTimestamp() }, { merge:true });
  await loadMySettings();
  watchModsList();
  watchMyModDoc(user.uid);
  paintHeader();

  // mod UI show/hide
  const imMod = modUIDs.has(user.uid) || user.uid === SUPERADMIN_UID;
  if(imMod){
    sideCol.style.display = '';
    modPanel.style.display = '';
    chatCol.style.flex = '2';
    onSnapshot(bansColl, snap => { modBans.innerHTML=''; snap.forEach(d=>{ const b = d.data(); const el = document.createElement('div'); el.className='item'; el.textContent = `${d.id} — ${b.reason || ''}`; modBans.appendChild(el); }); });
    onSnapshot(query(flagsColl, orderBy('at','desc'), limit(200)), snap => { modFlags.innerHTML=''; snap.forEach(d=>{ const f = d.data(); const el = document.createElement('div'); el.className='item'; el.textContent = `${f.name || f.uid} — ${f.reason || ''} — ${f.text?.slice(0,80)}`; modFlags.appendChild(el); }); });
  } else {
    sideCol.style.display = 'none';
    modPanel.style.display = 'none';
    chatCol.style.flex = '1 1 100%';
  }

  // watch my ban doc
  onSnapshot(doc(db,'rooms',ROOM_ID,'bans', user.uid), snap => { showBanState(snap.data() || null); });

  startPublicListener(user.uid);
  await refreshDmBadge();
  renderBlockedList();
});

/* ========= Onboard username submit ========= */
document.getElementById('unameForm').addEventListener('submit', async (e)=>{
  e.preventDefault();
  const username = unameInput.value.trim().toLowerCase();
  if(!/^[a-z0-9_]{3,20}$/.test(username)){ authMsg.textContent='Use 3–20 chars: a–z,0–9,_'; return; }
  try {
    await claimUsernameTx(username, auth.currentUser.uid);
    await updateProfile(auth.currentUser, { displayName: username });
    await setDoc(doc(db,'users', auth.currentUser.uid), { username, lastUpdated: serverTimestamp() }, { merge:true });
    usernameOnboard.style.display = 'none';
    paintHeader();
  } catch(err){ authMsg.textContent = err.message || String(err); }
});

/* ========= initial wiring ========= */
document.querySelectorAll('#mainTabs .tab').forEach(t=>t.addEventListener('click', ()=> switchTab(t.dataset.tab)));
document.getElementById('tab-signin').addEventListener('click', ()=> { signinPane.style.display='block'; signupPane.style.display='none'; });
document.getElementById('tab-signup').addEventListener('click', ()=> { signupPane.style.display='block'; signinPane.style.display='none'; });
signoutBtn.addEventListener('click', ()=> signOut(auth));

input.addEventListener('input', () => { updateCounter(); input.style.height='auto'; input.style.height = Math.min(input.scrollHeight,160)+'px'; });
input.addEventListener('keydown', (e)=>{ if (e.key==='Enter' && !e.shiftKey){ e.preventDefault(); form.requestSubmit(); }});
dmInput && dmInput.addEventListener('keydown', (e)=>{ if (e.key==='Enter' && !e.shiftKey){ e.preventDefault(); dmForm.requestSubmit(); }});

setTheme('dark');
updateCounter();
setInterval(updateCounter,300);
setInterval(refreshDmBadge,30000);
renderBlockedList();

</script>
</body>
</html>
